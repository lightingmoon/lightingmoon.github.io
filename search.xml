<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>对数几率回归</title>
    <url>/MachineLearningAlgorithm-logisticRegression.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>对率回归原理及其编程实现<br><a id="more"></a></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>用线性模型解决分类问题，只需找一个单调可微函数将分类任务的标记y与线性回归模型的预测值联系起来。而对数几率函数正是这样的一个常用替代函数：</p>
<script type="math/tex; mode=display">y = \frac{1}{1+e^{-z}}</script><p>令$z = \vec{\omega}^T\vec{x}+b$，则可得到：</p>
<script type="math/tex; mode=display">ln\frac{y}{1-y} = \vec{\omega}^T\vec{x} + b</script><p>，令 $p(y = 1 | \vec{x}) = y$，则$p(y=0|\vec{x}) = 1-p(y = 1 | \vec{x})$，这里假定为二分类任务，则有：</p>
<script type="math/tex; mode=display">p(y = 1 | \vec{x}) = \frac{e^{\vec{\omega}^T\vec{x}+b}}{1+e^{\vec{\omega}^T\vec{x}+b}}</script><script type="math/tex; mode=display">p(y = 0 | \vec{x}) = \frac{1}{1+e^{\vec{\omega}^T\vec{x}+b}}</script><p>，运用“极大似然法”，则对率回归模型最大似然函数如下：</p>
<script type="math/tex; mode=display">\ell(\vec{\omega},b) = \sum_{i=1}^{m}{lnp(y_{i}|\vec{x}_{i};\vec{\omega},b)}</script><p>令$\beta = ({\vec{w};b})$，令$\dot{x} = (\vec{x};1)$，则$\vec{\omega}^T\vec{x}+b = \beta^T\dot{x}$。再令$p<em>{1}(\dot{x};\beta) = p(y=1|\dot{x};\beta)$，则$p</em>{0}(\dot{x};\beta)=p(y=0|\dot{x};\beta)=1-p_{1}(\dot{x};\beta)$，则上式为：</p>
<script type="math/tex; mode=display">p(\vec{y_i}|\vec{x_i},\vec{\omega},b)=y_{i}p_{1}(\vec{x}_i;\beta) + (1-y_i)(p_{0}(\vec{x}_i;\beta))</script><p>最大化上式等价于最小化下式，</p>
<script type="math/tex; mode=display">\ell(\beta) = \sum_{i=1}^{m}{(-y_i\beta^T\dot{x}_i+ln(1+e^{\beta^T\dot{x}_i}))}</script><p>上式是关于$\beta$的高阶可导连续凸函数，根据凸优化理论，可用梯度下降法和牛顿法求得其最优解。<br>这里给出第$t+1$代牛顿迭代法公式：</p>
<script type="math/tex; mode=display">\beta^{t+1} = \beta^t - (\frac{\partial^2\ell{(\beta)}}{\partial\beta \partial\beta^T})^{-1}\frac{\partial\ell{(\beta)}}{\partial\beta}</script><p>其中$\ell(\beta)$的一阶，二阶导如下：</p>
<script type="math/tex; mode=display">\frac{\partial\ell{(\beta)}}{\partial\beta} = -\sum_{i=1}^{m}{\dot{x}_i(y_i-p_1(\dot{x}_i;\beta))}</script><script type="math/tex; mode=display">\frac{\partial^2\ell{(\beta)}}{\partial\beta \partial\beta^T} = \sum_{i=1}^{m}\dot{x}_i\dot{x}_i^Tp_1(\dot{x}_i;\beta)(1-p_1(\dot{x}_i;\beta))</script><h3 id="代码所用算法与数据结构分析"><a href="#代码所用算法与数据结构分析" class="headerlink" title="代码所用算法与数据结构分析"></a>代码所用算法与数据结构分析</h3><p>因为目标函数是凸函数，所以可以直接将数据代入目标函数，用经典最优化算法进行求解。    </p>
<h5 id="Python语言实现"><a href="#Python语言实现" class="headerlink" title="Python语言实现"></a>Python语言实现</h5><p>可以将格式化后的数据集存入文件（数据集较小），每次运行读取数据放入内存进行迭代最优化求解即可。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习算法</tag>
        <tag>对率回归</tag>
      </tags>
  </entry>
  <entry>
    <title>微信疫情通自动提交</title>
    <url>/autoSubmitTableSystem.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>疫情期间，学校要求每天都要提交体温等相关信息（如果不按时提交就会被全院通报😳，为了写脚本付出了仅有的一次），就想着写一个脚本放到服务器上每天定时自动提交，付诸自己好几个月前的想法。在这里记录自己学习、写脚本的过程，同时可怜一下学校的服务器。<br><a id="more"></a><br>写这个脚本用到的技术，经过研究，可以用Python的selenim库或者urllib、requests库，但是后者需要更多的Web相关背景知识，由于我用进废退，脑中残存的Web相关知识只剩那些最基础的了，还是在实践中增长知识吧。</p>
<h3 id="1-尝试用selenium库"><a href="#1-尝试用selenium库" class="headerlink" title="1. 尝试用selenium库"></a>1. 尝试用selenium库</h3><p>　　这个库的学习成本极其低，一篇博客就可以入门了。<a href="https://www.jianshu.com/p/6c82c965c014">selenium教程</a>。看完之后就着手写脚本了。疫情通的整个填报动作分解如下：</p>
<pre><code>登录-&gt;获取地理位置-&gt;提交-&gt;确认提交
</code></pre><hr>
<p>但是在脚本写完后却遇到了两个致命的问题，使我不得不转向使用urllib或requests库。</p>
<ul>
<li>问题1：Windows系统获取地理位置信息具有不稳定性，每次脚本运行到获取地理位置时大多数都是要么定位失败，要么定位不准，在这种情况下只能放弃这个方法了。</li>
<li>问题2：js里面弹出的确认框wapconfirm并不能被识别，好了，一朝回到解放前。<br><img src="https://lightpicture-1257032496.cos.ap-chengdu.myqcloud.com/blog/wapconfirmCode.png" alt=""></li>
</ul>
<h3 id="2-尝试用requests库"><a href="#2-尝试用requests库" class="headerlink" title="2.尝试用requests库"></a>2.尝试用requests库</h3><h4 id="i-分析整个表单的提交过程"><a href="#i-分析整个表单的提交过程" class="headerlink" title="i. 分析整个表单的提交过程"></a>i. 分析整个表单的提交过程</h4><p>据我现有的Web知识，从登录界面开始分析：<br>根据观察，在登录界面点击登录之前该网站下只有1个Cookie，<br><img src="https://lightpicture-1257032496.cos.ap-chengdu.myqcloud.com/blog/cookiesList0.png" alt=""><br>点击登录后，会将username和password用ajax技术通过post方式提交到验证登录网站，</p>
<p><img src="https://lightpicture-1257032496.cos.ap-chengdu.myqcloud.com/blog/login00.png" alt=""><br>验证通过后，该网站下的cookies由1个变成了4个，</p>
<p><img src="https://lightpicture-1257032496.cos.ap-chengdu.myqcloud.com/blog/cookiesList.png" alt=""></p>
<p>接着跳转向填报界面，在填报界面根据新增的Cookie，后台获取该用户的前一天的填报信息并填好，留下地理位置需要手动获取。获取位置信息后，将之以post方式提交到服务器。</p>
<hr>
<h4 id="ii-大致思路"><a href="#ii-大致思路" class="headerlink" title="ii. 大致思路"></a>ii. 大致思路</h4><h5 id="1-尝试直接复制出整个data包，以post方式提交至目标地址。"><a href="#1-尝试直接复制出整个data包，以post方式提交至目标地址。" class="headerlink" title="1)尝试直接复制出整个data包，以post方式提交至目标地址。"></a>1)尝试直接复制出整个data包，以post方式提交至目标地址。</h5><p>经过观察，data包算是解析出来了，但是这个数据命名实在是惨不忍睹（变量每个汉字拼音的首字母，现在是知道了阅读变量命令不清晰的程序的感觉，<del>口吐芬芳</del>）。用Notepad++的Compare插件对比 def（今天要提交的数据） 和 oldInfo（昨天的数据），发现多了后面4行数据，在页面找了一番后无果，索性在处理了一下def数据包，直接提交至目标网址，但服务器响应返回的却是整个填报系统的登录入口页面，说明在提交时，可能服务器还对提交者的身份进行验证，具体应该是通过验证请求头的Cookie，最终还是要进行模拟登录。<br><img src="https://lightpicture-1257032496.cos.ap-chengdu.myqcloud.com/blog/diff.png" alt=""></p>
<h5 id="2-进行模拟登陆，获取cookies后再提交信息，最后编写接口程序"><a href="#2-进行模拟登陆，获取cookies后再提交信息，最后编写接口程序" class="headerlink" title="2)进行模拟登陆，获取cookies后再提交信息，最后编写接口程序"></a>2)进行模拟登陆，获取cookies后再提交信息，最后编写接口程序</h5><p>经过分析，整个脚本流程图绘制如下：<br><img src="https://lightpicture-1257032496.cos.ap-chengdu.myqcloud.com/blog/submit.png" alt=""><br>完整代码见我的github<a href="https://github.com/lightingmoon/BlogSourceCode/blob/master/%E5%BE%AE%E4%BF%A1%E7%96%AB%E6%83%85%E9%80%9A%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4/autoSubmitForm.py">明月光</a></p>
<p>邮箱授权码获取方法如下图：<br><img src="https://lightpicture-1257032496.cos.ap-chengdu.myqcloud.com/blog/getauthoritiedCode.png" alt=""><br>参考资料：<br>提取用户昨天提交的信息的正则表达式来自以下大佬博客，自己也该好好学一学正则表达式了。其中发送邮件方法也来自这篇博客，丰富了我的见识：<br><a href="https://blog.csdn.net/solitudi/article/details/105066215">记一次SCU疫情期间每日健康报送任务的自动化处理（一）</a></p>
]]></content>
      <categories>
        <category>自动化脚本</category>
      </categories>
      <tags>
        <tag>Python爬虫</tag>
        <tag>表单提交</tag>
        <tag>模拟登录</tag>
      </tags>
  </entry>
  <entry>
    <title>将Hexo博客部署至腾讯云服务器初体验</title>
    <url>/deployHexoProjecttoTencentCloud.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　最近根据相关法律法规要求：域名在哪个云服务提供商备案就必须将该域名解析到云服务提供商的服务器，这波操作秀啊。这下白嫖了两年的Github Pages服务也用不了了，为了不放弃我这个域名。😐。弱弱地买了一个弱弱的学生(qióngbi)版低配服务器，花了一天时间将博客弱弱的部署到服务器上了。在这里总结一下自己踩的坑。<br><a id="more"></a></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>　　考虑到网上有很多写的不错的<strong>将Hexo博客部署到服务器</strong>的博客，我就不重复造轮子了。下面是一些我当时参考的博客的链接：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_35561857/article/details/81590953">带你跳过各种坑，一次性把 Hexo 博客部署到自己的服务器</a></li>
<li><a href="https://blog.csdn.net/wx_15323880413/article/details/104576799?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">记录Hexo部署到阿里云服务器全过程</a></li>
<li><a href="https://blog.csdn.net/NoCortY/article/details/99631249?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase">从零搭建Hexo博客并部署阿里云服务器（奶妈级教学）</a></li>
<li><a href="https://blog.csdn.net/StaunchKai/article/details/82878928?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">Hexo 博客部署到腾讯云服务器全流程</a></li>
</ul>
<p>　　<strong>只要一步步仔细跟着教程走，应该不会遇到问题。如果遇到了问题，可以参考博客下面评论区或者在搜索引擎上搜索。最后还是解决不了的话，可以请教周围的大神或者在教程博客评论区留言。感谢互联网，让我能站在巨人的肩膀上</strong>。</p>
<h3 id="踩坑-gt-跳出坑"><a href="#踩坑-gt-跳出坑" class="headerlink" title="踩坑-&gt;跳出坑"></a>踩坑-&gt;跳出坑</h3><h4 id="1-安装nginx中间的问题"><a href="#1-安装nginx中间的问题" class="headerlink" title="1.安装nginx中间的问题"></a>1.安装nginx中间的问题</h4><p>在解压完  [nginx-1.15.2]  包后执行指令：</p>
<pre><code>./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module
</code></pre><p>会出现类似于这样的错：</p>
<pre><code>checking for OS + Linux 3.10.0-957.el7.x86_64 x86_64 checking for *** ... not found ./config
</code></pre><p>中间的<em>*</em>可以是任何软件，此时只需要手动安装那些软件即可，例如：</p>
<pre><code>yum -y install gcc
</code></pre><h4 id="2-万恶的403错误"><a href="#2-万恶的403错误" class="headerlink" title="2.万恶的403错误"></a>2.万恶的403错误</h4><p>　　这个错误应该是相当玄学了，如果没有这个错，我一下午应该就部署好了。反思一下，其实自己一来对linux系统操作不精通，二来对Git操作也不精通，三来对服务器nginx了解也有限…大神的博客也不可能面面俱到，所以在自己知识有限的情况下，只能找寻前人解决的经验了。<br>　　这个错误，我在试遍了评论区的方法后没有作用，后来不太清楚过程的最终解决了。所以现在只能模糊的猜测当时自己修改的条件。<br>　　我在修改好本地的配置文件后，运行以下指令：</p>
<pre><code>hexo cl &amp;&amp; hexo g -d
</code></pre><p>在命令运行后并没有发生错误，我登录进服务器发现网站根目录并没有文件，在我用git上传成功的条件下，网站根目录并没有文件，这说明建立的裸露（bare）仓库的钩子(hooks)没有作用，这就有两个原因：</p>
<ol>
<li>写的钩子，即linux脚本没有作用，可能没有执行权限。</li>
<li>用户git没有博客根目录的权限。</li>
</ol>
<p>所以，我从这两个角度入手：<br>将教程中关于这两部分的步骤检查并重新进行了一遍，设置完后让服务器nginx 运行reload指令一下。之后我访问我的服务器的80端口，在失望透底之下竟然出现柳暗花明——访问成功了。</p>
<hr>
<p>最终解释：写的钩子没有运行，在服务器手动运行一下折衷。还在找解决办法！</p>
<hr>
<p>找到问题了，表示很无语。原来是那个钩子的名字必须是post-receive，当时自己可能太着急了，把文件名打错了。我错了。</p>
<hr>
<p>之后的工作就是等域名的证书验证好了配置HTTPS</p>
<hr>
<p>Ok，HTTPS配置好了，具体没有踩太大的坑。主要参考以下文章：</p>
<ul>
<li><a href="https://blog.csdn.net/Tencentfly/article/details/87990722?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">腾讯云服务器申请SSL证书, 配置Nginx, 实现HTTPS
</a></li>
<li><a href="https://blog.csdn.net/yelin042/article/details/78584172?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-1">腾讯云服务器https证书安装指引</a></li>
</ul>
]]></content>
      <categories>
        <category>Web技术相关</category>
      </categories>
      <tags>
        <tag>踩坑记录</tag>
        <tag>资源集合</tag>
      </tags>
  </entry>
  <entry>
    <title>三省吾身，一往无前</title>
    <url>/accelerateMyLife.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码，查看文章。</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="d4367a51c185fa974ab3b2b934a9df0940ec84122f14770231f8ad6ad48a7211">6010434d3f7c9b7aab2f21cccac0af41bad065bed42c2e05d395251ff4c309f317a65191bde981fdf944eb36f80f022e9d804e34696ee63b62987f9b0be6a1671e28269ae3f6263c76bf69fbf0fd94b448baf70153406d31e697ba390a27578836aef84b6e1918d289a1969cd502d61ddc20ed1aba79b410e38ad3a677b5ec859661e067d61aa10235a033e4485d967193d883d648d366d6793e10a58a56f26faf4a2ba1e69d2d2010e731bc13ab8456b79c16265b38c24ad70e48727991af228e54e87096e2c6e8a52946cf6197000899316e6541a021969bf3889a5153d99132d8a20b237b6b33cdeb203b6a11ee0b5e197eabeef802a1324ec5bbb1c1dc7d21dca5b2a4d628138c30ca2548da0aea1f70621d564a5cb6e607a2b7ebd804217f18bf09aab520f1c1d530cc365340dfc4631fed86911cfe4248bff008e9ec3ece7e5678b29aab652d09af63c8fe1aa05c7f30840eeb1dd15d6c1f28b7603f518dc19472c841dfc5f258d930c0d7ba9f8b143c4dd59d60a925dcfe0038d160d2624367b1bea7a27f6c1be4b51466db1789bff27cd9e5bb35f304191e4b64b569e2f1d267da91f1e5865290190ec5bebdfd4b7c904309c023371a68ac6173a81e77c2b4b16e305647cd83af8af8fa4e0ce7460c3779faeeedc070843b94dd13f4f1d3a0b25785839223208bccd3b388293dae22a22c5c6e96cf6acc899c0e74e57ab86785ebc441800f52514eb48ff3391ca1f804d3726d2ea81348f09f9713c566a3022edd396bd435e988ea60d86f19c7e8fb5d71f69277760de9fb52f5b858c27e8d76d664c1c2d3f9982e99984ff7cc22b6415faa9e42866248248e3a6609e15e12b1410e42128abf0bc684f30dcdb51e00e5fd3575fa7907ec65b0288b062bde99bea89f2a39a1a709a359140a47f123e15f04aef81eb4ee2d5660fe2337b38c2414c11099ab76e46f93cc1327d55341f898c74635d9a8c0d9360caf54990dc05a2e264a0ec900ff40247745890ce040d1542a645c4804f63a0181f0e61901d86bf01d743e912cb7ccad6e5245040619cf69d5e5391c33dfcdda471d46746637819a4ad4741cdf0cc3f438a5cbea927c47572e841b3d5eeb225af21c70ef7a1d30563025f81d475610da104a2789a8e5117621ca51cdd020fc3dc994d2aa34fb0b8d8a0fdabf0fc68527c2b24ac7155fd711938606e6d027bf3d97f958a00b2b9c7d919422a4ca0983221f60c5dfa8564fb3568033cb47065771afcee7f56c083c5176cd75228860e049b0ab5b91c807408a256312c790a7484a7909bc058ab85224abd002fd03878dfe29cc752e4146237800ee2fff9496c32ebb66c75f4ec12be67de16d9929f9cb64527dbe588b9b85d660c78a4e41ab714469647c0fa97fef7cb4c47f94a4807bf388bc3f9ebfa2c0e9c8686a6e54d374982ae4946eeff43beac34c9e5177b5449d03b9453394463e92e7c4649ea56064bf834bf451fe7e9ed3b6124d9617ecc5af5d7b903485cc972b1a2dd1585091ff7e5d39f1d5c54ab6ff2272d2b2b263c1ed23a620e49ae1c70c6f3cf549bfb98c23cb8183cdf7b780a5ab16eddb704ccdb2116ae4ea0e4f1d7299e9ecfb553962dc183b7f630113502c83f9282dbf8412b50ef22460f2f835425cd4a1c1f82d038e8228e5356f8bbf6456229e41197ad17081fd7e13977a71e4a37f87bd924bd75570da1800a543e409380f4edad9a227a2141906c13b1c706efb6d8d0aaf2c770cb7d0f3670f9c9f4071166b0e73620f66ddf61b5af1f7c677d1c70c047fd54aee6ee6b3260232d08653eabbf21bce5fe1218bbf58ea459c5861dd0a710c974a6e159168139ba97ed04599ce02b90b86047f4a30bb08ca629f98411b06186bb650fcbc3150c19051a90412ac12aa47cb8a4fbeede78bc9e2dc28154318478e162cf64d0574533ef7d183c826c124155b600735a9bb0c9cd4090d8ada315c00fd407e40e670eb80d91f606fdebfbc62a0c2aa58878d3b494598d12c9e08c3093b43ee7eda834fd2510647754de7df8da08f4ea262608fe8c07d457558f88f45ec19e5bc808174b696c42980a6a3aa486fcc70ca1841656b9a7e34fb81a0fe9c09c32342b91e69a958d4bdcf49040617b29458574619cbee249dcaf0c76216216e2d8c1b3d32063f2e31d62e2cf4cba75ef2e6ef5a94f36d1699556dd23fe8568ce61771f1b37d84b5867511993cd6e8d30d0ce99a91a38f518ad2ccce8ed0ee7f4bf002fc29f1bac175aba1da3bbf0fd643ba12bb23979f11519a066db5f92ca5d1ab8c26a4875cfcc3d16db43e33d56a9522a31810d50d96eecd7722c4d2760bd7157ed3e22e965bcd37f4aaf22be8111d47b6a6b19d7faf65eb14626c88099eeb255d0fbe06ed8bc4166f0b741dbb884de0f5ddf6d8471c484aae9e3d56d93e8ab376046c30dbd639711ac9f2b91562202166e813522c794115a818893b35eddd74da6015d04517763fa1ab236db3256e91ce4c4e13597940aebfc9ae2ba90367a3308ebdb7ea8905e0849337df5263c29428dbf457a6daf4b7f2819ad6c509ba24271ca6a67366299f50b7a765273924cb8f831b39116e032a46cf4513135ca7bc95f87fd6460a110679a7806976e99b7adc8b3243fe528fb02d89bba081ee2fa7f36aee3c5d301053138fc0a91482ee321d3aace42bbc3c7d9c81aad61e5ede15616cb0bc59699df72e55480cf6353e94aba25f963e596db0df3feef249c53d1c964698d08939785049659a550ef053d970514f31d5fe1f499160c01c7a88df0e6185c358aaf8f1e8f3e1eb6bd57a9947efed2bab1e92839c8aa8e2d2852b29f13845cb59a262593ee3a2ae69b9cc7b4dcb686441c96c3f23211e50e4f6427f6c7dd921fc4f900bdd38cf29e9c5471c1a280e61e8a4e824d95c1e6a7a96ad40782984c7730d57132b3fdefaf8e9d40d7cc4ba82724cc1d4978052d6bba6c9f855e22ba23ed97ee890f93404794b8ebee1056f46fd65a282846c376f48bf40051365f13deaeafce2d0e2df80d6bf9504dcf56b0116708347c1aad6e5311673067820f9262d3d823106c9127917792678083e52ef6bbdbf543216bef60115e452ee6046efac22af847ccb6773622d355497f45b1cadadef25b1471b46e471f30179c7885e789265dccb70602e6bdf3117a178663cf03e807531d1e47df7408a14eeb34ba0a3abcc1c22f49d1faf0457c6809b4dfce4dc3fe78ff48207f9eabd1a489673b61d621c5ed90a6cc9781c5602ce8d4b33f1a2918a95ae28d9eae34ff4a3b8c22f741f8fb7e95dbae0fb54a6c084d4c6bf90d29ec82df063c85e704e77e431e0d5baf5e61f08f9d62f4ff4d5e2b7887703a4e6b2efef74b007ee29006b5eb405983bb5579272006260e9db3f336bc29ff7b1507bc002e7b1dfa53d2e97b01017ff6ed3a25695cf4484982005abbe5474b646b5160642fa82b2acbcae1152ccae65e55399b838cffe51ae6ef6b4d6a8b43dd3a99c75f8ac741336168ad582591abb5501d531f9fb5f134a986c082b590882d0db2065c73487218458cbdb06d4deec4a7e91eeb74c20deace3fa56461f5792e70059564ea2a05e96138292c65e7552fafa0f717ceb1cbd3d47670708e97a56d26f0d85131694ab29bbb906cda2b3f2b7229a85e5f658cdc5cd54745e140430723a4b8cc7a8df0879fac335b67e5651e148b99f35fa2efeac740cd6ebe407721f20a1c3aabd39bacd2d2c4c10b17af1d5d5716e9ed746cff51438b17172fdfff46c322623373028cfa94988fa26faae3f6581243acf572ac17f98e3670372be13412daeb1bf914cb6070235172dc83cd6f08aee6dacee52aadb52391526efa937cfec2eef192780286c5a584a6c8461c60dfc185006ecb49ac6be9423eb0f577247a67e8393277be16301eb312c8d5027bbed21db5ab7814cde61d0ca637de08decca2f29a99e46833332984b56fc454a4a8ccafee048e015649250c918c92409572affe2f51549c7441cc8029ddbac58bd7ae6adb4419509ef7fe08f0849adb548dec96c32017f604d43f88efd301154bb84d7a3bc01f52999afbc060b94eeed7628c575214091092fa9a9dc70713fbd761856e6bf9b616ba2eacd4a79a3bec7cd2a733a43d6d64ba0d46704f1f73bb5f1dc9389a57fad41356742f8892eb322bdbadbd8f58b300f87914c2aa9d65f3c117a2b6979f53de5dfcc0dad93ec531e649845198e7b13e65f779bdada7742a24de1293b623ebf82c1f69c3b47d7fa6de1582fb7b15888bcfb4c42b5eedc9c2f35975aefa3b40000230cfda05b501da879f4347be85374daf33ed163feb854f16a3a580101b45ebed65cd92a306e30b05daaead748a9da8a1ebee6482c3390a295bb86d64ff47913ee34a4f2cf2468726f3e1b21ee03856716848155220ce92cc912496112a1bf7de3f77957fe0693a9e956e3321bf42afdc85b1abb4dbc482ed36e2df792dced7c41c605079d6e49112e8c97073c5df6f0426534117607e509674a761c871959429768a515fce7ff90be7a1def0ecb8f83fd400400a04b49893a37756af1a497f74fc49b10867cb78b93b58ecf687254255a09c747f22dbf9d2d3ead9af88072892a94566e183e88194a38e880aece70f35432e2c8234e346d42b27b2219f5c4dfc31b711b1c7748c2bb2790773f8e9ce57c197d40cd6ea93de72d1bddfb3d21d3ad0cb344fb37a5821177ddd76b6591928c66fb1ed85b206800174eecbe5353292a459011c0530eaae8a4c9fe360ff3b8133777eb737c5fcacd01e9bf14775023bbbb7278af9d827ed21fd502d156d590528031d30bfd6f345f4df8f5cf1e9bdd687926e2589f5525b759cf6cf68ed85b2ed6f7b06707c58059e8cedb766607222374b569685ea5d94d87899792c1806f88a36a6cd8621cbcd0e139dbd2ef5955b08add11611d258702bf1b5ec51d4adcab6f41a73fd0c6aeedd18d7405dd5328b4327f7e2ea78e5f55d0cbdac8a1507aba7a4cbc695a0c183a4606d024a8a912b1f4f253bc15a749ab8e96e76b43564773b79a99fba101304fe509cc12695b82553cd614d7dfead9987ca7a95215c3378181e3137399a742962496364e8b0c9a9499372674a188011f7dbb296257989b1acc765da235e2e0f9800ea951b73ba1786a6d63d6b3ee1c1a61fe891df4c22d6374598eb51a9b418d2cc15b002fd036eb9d216b781a61a67f63e4b8fad0b5ef9b62227ae42df20adbfe2cad007d14164b32f170c78f1ef9711c1052dfc332227a7a28fb75e802e22f96e7c2500949a5a5f7cd013bfe3e5e791aaa1b1198d49ba9a669f2d890815bd7e628165869284419e5eaea9fe66370984ac461f0abce9ef1d87a5729ea7c34e531514ad688a4fc022c263ac76cb2d7c34a559898b64bf444e1471e115a520ed43732206a7b4d80c9efa80651706efc08c9182da5bedb1b9bc3a47506d4434fb960a4a0dbfd9e3be0f58a4da2108d513697275b4025207cae9dfb7816bbee83a3ff2785a17777fb2c9669edb8904bb6f82a4c700294072db44e5170b181d72b179d698975b94ac7057de03e664dc891795a72a94938735f23f28066a696a0c8b1d5f9807ad5272d84cb8e17666660f6efc3d589d3d92a08783dbc0f16859d8a665ad253f2445d101547305832e6ebe5c470e864444e39feb2ed967035e203b214db2ead26b81064a3a5081435b669a2f088318d7357f8d9b17738017f07b49a77b4c343c4a1acb47b3ba6742cf598b9fe1bed9e13d4c3281558736bb6c4fce5a784375c669578675f5154198a04201bc2b70c2c5118d41516209a372d13ce8fcbc33bb5831aa064b17f7ba6c881b7cb234a8acf95806ba17d816b5657c7a4122b5f1be23cf506f8de3a7a2dbfdfc5f5ba4123faa6af51985c52130058bd5ccaa6585ea5ad7788fea789da145f0048a278ddeb154754a280bfb79b9fc48d830c98f9be9de71a88a53598c8e444be51a5c74f5e3e54a0e9503caed659931bc418896685f4b36c92f0e62936c3650e4b159c50f4c382de1a91ad1f2d654debf9f9ae5a66da06e667ff09cbc12b827ff7a2272fbe57e54c72751b2305bda6d2b2f7ef7c4f5a178ef44249258e4e54b8e21e88746d638aecad11626a96f42c2a3e21a2ccbb7d9048e9864bc3d3e44ad05fdc6b7a48a508f151729f0a8dc09c85b0117b16c380468eddaf7f414663d7835ac17bd39547f4c677b6de9278aab5a266830b804a527df901cf70cb53a9074e97fe087358ac44d2cc8dc2dc4dd546289f1dcab359e4c2f2c3f7602bd26b8591112b10225c76467e85f3a7d10aa9d38e8ce9f33ad630688ec11fdef84087431781fe35f5f496608536bfa9e919dddfcba3f58a395b1b1bb2c91602664ea6b340418902f6d6ae70ebbbefaec1986bced502df7e8362fda21b63f8e7ba6835cb0dea8af98c07feb1507628c059c28d9f4c4c2b1a31de7a641d8ac156a27948f29206d7bae30f0cadc6b527de11229027d0aebb3c7581799777ab4d097cb0d39444678ec3e5449a265717fa87c14fb10a6a0f11b549ed68918c12834fbc573da0782862dd28f649a07b33454af67ae3d8ab3205dc53151c91286e09cb90d4c57005e80942317aa4323866fecb5864113c7952a2e1303df26bcf0ab7cc9223fb81ff013a32342f976b539e9dc9334da57dc424207a8e3274beb3034cb6c3dcea123fc9df6658f24b1fb1161d93b18cedd8025366cc7597f29fadfeaec7b549a42b1bd99877aff5203edd961b327b30fda606f7ce1a77441781ff5fa86e05afe7b9ae5bb21b5142ebb33e33a9f974c7ad96e87e43237df1192263297db6a0bc53e230ad97ee8e3a79822973bb28bb277331e8ba044e3eede1ea0c69db978dbe8007f59637f5871319f0e276fe93478e14a6635e7c744ecbe778b38008fd0008fc2cd9c02a6570c372b14412fc1f6aaa2800c7854483ab6520bc54723c55c5a63a8c8aa6c51c64495cdb35ad2c03f2a14a53ceff56dd623579a7e51204f965cd1f465189205597aec72293ae83496455ccc9b80fb7b2e97150125edf4de9193f45523423fdeefb96a9e36132d953c1c3a59badca2c24970f0ae275071e545877cad39b637c7b3e53ccaab5d49dfe4cc0f47266945f5781ff939a7861d5ba6235fb40aa8bd9132eb84ac7dbe78c6e3fdacb73b961b949197e4ecd12a357e3feb3c5eecd48036aa23541ee75f0c45483133dd891468e35684ea0644ea388f1d98a36f328584defc18c2fac910e8409d50854c706160b9306e882b352ed3e407bd58bbc02b888e72befae1c0f7f125fea877c59df075a3f1596e288fe5f77769b4e5f499c2ae6f221f422d8f5d9116b14dc172de3c165f734a01094341e1d642f2de0d65fb4fafdb4ad2a8fa8052ce79f87f802cefc7122a001435b592060fd52ee2f4c0a000accebed6c38ee7000dc5517d1085fc78245534e534a8c93e910c8664dfc2d4396f625b804dbc82c96bb3042f889e875fa93ad9d9f4380c6bad2a1fe17f3e2e40383b5cdeecc0a0a09b9c29d4850cab4246252422bb63238459df5c3bcf61b95e8f157be9c1edfb0f9da81162a826da853086b8ed2aa947c4f2423b9a7c3327b0c41ec4fbcbdfb1f69ed115c9496517df7bbc30b2f59e8b00aabdc0dfaa4f89b532ed0a9207340e5ec11aac74138c134b895b4c7bb3a7b97068ce881497df96c94039ddd375d96c4adcbb96e4dce8551e07393e0dc72321185b24cb10fe3913d9286f83751cfd59ec99a2aa4fe0fa489ae4ce04072013d2f526ff87cea87d7000424c17c7b11752723670f5b9fbc54b0d412f34a54c3765c16b5cdfe5beb1d8538826aec6256e77c9089fabe3cc436d42eb3b40fb198b652b02390e76633f7de1cda7b7b401e4087b55395d41ce8127b70be1c5f1001992b2e89389753b4b2f6a3cd40c201248083b937aaeb0bacd524806cccaaa6dee60bf4e4dedebec721f2b958e86b5b1aeb06d6e1e2d8cfc554aa214a0e114ec98c9c1cd17a076156159d9070634af869a756426561732db258f30de6573d07e6414ae1e98d4004181aa9df0bcdeda66392d3942c9957ed0daee7b739365717a4482dd29b73e1b19f1e4fc8ac5fa37b28d1c7ccfd18981e73fe4376841e5ef5160cbc79d2be622d46edf61768bd7c3307906e518c5642245ddb53f3492b09cc8cd25044d9dbac7e57a2de814e573fd3ef98bc9d47b17b59fff2e357c6854106d1d290fb3092bf377556b7721bf3956049f4d8f156baa742870cbe1f7aabba7a2da05899739c99c69a659510f962a6dad6e3d7da98874c12ac7a2b9b111521bce22f05c91e4996fb04ed350296c83fb984112ef54c42fe3fe979ecc5fa7f7c7302257b649354d1581c9c7efaa1e81fe48d86ed0011f440d87ffc83e56583f37527d98eed96bec107520e5767dea680da6aa458eb70fb330e54ac8cf37f5cfc0d7b0fc90726086fcefa8dff4564b5d8fbb471577b54612feee0353d1f601d3e7420966de303443ee2a342b313c16e4b69c2d7f87a51158737049cc8e6eccdeac47cf02152399230c41c3e10c7f5a5c4c12bc2662d134f1f486e4a726d98ff6d202307f51760d87c2831717c15ed66c051f5cd0f3fe94519750227e98382b223bff0d457c297ef7f05a197cdcf9cc3056df200b8ad0b44c626e0a653d3e77dce0e1da2e206b23d9c019d92a4e09cf01bb53b6041c4c2e9ec434e8368729b18790c1cbbd4f1e445a426b320d9c6a06280e2a056e5809986a218488e196406f82238fc80f19141b14bcaa0cfe8d85fd6da164042de129541bfba3ec9caef0f64755a13a0f1cab375ff45c77ece0bfb511ba7115963ea4b09dc9f4a03a2922dcd5fac046eb5bf55c7afd2ba2d8330bb153240131f0a4793af88ca18ff0ec7ffed0851b2d4d8d801843a368d5711d5455144146a271364cf28a676354eba0a17e2311288d39ceebb7f21dc6cd83473aeadf7ec1804c16d36f62101d1496d8001b640705646da3ce71458bb378fd8c8d2d2abf938d90cee85d6d6a29ff5b4d9fe66ce44f36d0fabf3e5e248877583c2b73bc1cc776e63783f539b8ca6bbe7b3a9f4c4834c0463f226c59b94736da148d380b4cac6d622404567ef0bca186a45262a76ab864abd46b04ed541ade4f49bd26e77e31958e27bcd33107b3392fc143ae165ac4e04b491a03ce4d1c11a81dfd2c137fc704178562bb5ba4a33c7e7e8d7c49c9e15218a1584d7bfab05c793bb301afbf07ee59cc813c333981d8444574a2f4b52d3928760bb69e358aafd9d0bf750f0fdd3ab4ab6c69f72582cc18cdb4ba572e38132969bd07fcc43ab8ce3d6124ffd96f2d66e9ba0f73d20c74befe580b183f0bb7484d296c45fa867097bbd8e02c333bfecf6a2a0688f68975d35d10028c81210427f73f3cb7d75cd78a7ff73c5dac30885e374748f34f4fe29bb243cfbfe29b7851c0b971399f9618b40c93e9978e482f04ada00738749fb0b32ee72624a29eb5257b26f7cbd7074c1dc3353f103ffecb978df63d11a36953e3120d12b936fd4e9917905febe51d89263ea5d90fa3b4c8f745942c674c73434c5ffa98e48517823d8cc2a44767746ecb251f4344b5225b6d502bbd9c2f6db1bf0</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>静夜思</category>
      </categories>
      <tags>
        <tag>自我省悟</tag>
        <tag>自我调节</tag>
      </tags>
  </entry>
  <entry>
    <title>一些Word操作技巧</title>
    <url>/someWordOperationTips.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　最近想吐槽一下当今的软件设计技术还是太死板。且听我举一例：我向某翻译软件上传一个word文件(.docx)（是一篇英文论文，里面图片比较多），翻译好后还是下载的Word(.docx)格式。我打开后开始对照修改，改到中间有部分内容缺失（超过那一页的边界之外），我准备打回车把那部分内容顶到下一页去，结果死活顶不下去。<br><a id="more"></a><br>仔细一看，好家伙，原来那个翻软件给生成了一个表格，只有一个格子，它把整个翻译后的内容放进格子里，那个格子超过了Word纸张大小，只能看见一部分内容。所以你打回车是永远也顶不到下一页，只会在看不见的地方增长格子大小。明白了以后，<del>我就口吐芬芳了一句</del>，从此与这类软件做路人。虽说可以用表格来排版，但是您也要用的标准啊。这样做简直坑人于无形。下面开始本篇主题。</p>
<h3 id="1-关于设置页码"><a href="#1-关于设置页码" class="headerlink" title="1. 关于设置页码"></a>1. 关于设置页码</h3><p>1.1 从任意页开始设置页码<br>　　在功能区<strong>布局-页面设置-分隔符-分节符-下一页</strong>，接着在该页面<strong>插入页码</strong>，之后双击这一页的页码，在功能区<strong>设计-链接到前一节</strong>，取消<strong>链接到前一节</strong>，再删除前一页的页码即可。<br>1.2 设置奇偶页不同的页眉页脚，再添加连续的页码<br>　　其实就是分别在第一页添加<strong>从1开始的页码、第二页从2开始的页码</strong>，但是也要注意，文档内不要有多余的分节符，否则会很麻烦（Word在添加一些比较大的图片时候会自动添加分节符，有他的道理吧）。具体查看分节符的方法：<strong>功能区的文件-选项-显示-始终在屏幕上显示这些格式标记-显示所有格式标记</strong>，选中它即可。一般分节符长这样子：<br><img src="../image/SectionBreak.png" alt="image"><br>想要删除分节符，将光标移至分节符后面，按<strong>delete</strong>即可</p>
<h3 id="2-关于Word输入公式"><a href="#2-关于Word输入公式" class="headerlink" title="2. 关于Word输入公式"></a>2. 关于Word输入公式</h3><p>　　按Alt 和 = 键，即可输入Latex公式，且微软支持的很好，渲染的也很漂亮。但是却只支持.docx文件，一般学校都用的是.doc文件。不过在将.docx文件转为.doc文件时，Word会自动将Latex公式转化为图片，支持的很好。欣赏一下Word输入的公式吧。<br><img src="../image/Formula.png" alt="Formula"></p>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Word排版</tag>
      </tags>
  </entry>
  <entry>
    <title>基于高斯扰动的粒子群优化算法算法</title>
    <url>/GanssianDisturbancePSO.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　在碎片时间被智能手机APP大肆压榨的时代，我们只能从增强自我管理开始。以上是自己最近的一些思考。欢迎一起来讨论（👉👇）。下面开始本篇主题</p>
<a id="more"></a>
<h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>基于高斯扰动的粒子群算法(Particle Swarm Optimization based on Ganssian Disturbance, GDPSO)<sup><a href="#fn_1" id="reffn_1">1</a></sup>，其很巧妙的在标准粒子群算法速度迭代公式基础上增加一个高斯扰动，使得算法收敛速度加快，且既能帮助算法有效跳出局部最优值，又能扩大粒子搜索范围。<br>具体GDPSO速度迭代公式如下：</p>
<script type="math/tex; mode=display">v_{id}^{(t+1)} = \omega v_{id}^{(t)} + c_{1}r_{1}(p_{id}^{(t)} + r_{2}gauss_{id}^{(t)}-x_{id}^{(t)})\\
    +c_{2}r_{3}(p_{gd}^{(t)}-x_{id}^{(t)})</script><script type="math/tex; mode=display">x_{id}^{(t+1)} = x_{id}^{(t)} + v_{id}^{(t+1)}</script><script type="math/tex; mode=display">gauss_{id}^{(t)} = r_4gaussian(\mu, \sigma ^{2})</script><p>其中$\mu = 0，\sigma ^{2} = |p_{id}|$，其它参数与标准粒子群算法一致。<br>据算法分析，令$c_1 = c_2 = \lambda $，当算法参数满足：</p>
<script type="math/tex; mode=display">\left\{ {| \omega | < 1}\atop
 {0 < \lambda < 2 + 2\omega}\right.</script><p> 且个体极值、高斯扰动值和全局极值保持不变时，算法在$E[x]^{*}$处渐进稳定</p>
<h2 id="算法进化模式分析"><a href="#算法进化模式分析" class="headerlink" title="算法进化模式分析"></a>算法进化模式分析</h2><p>令$c_1 = c_2$， $r_1 = r_2 = r_3 = r$，那么种群所有粒子可分以下情况：    </p>
<ol>
<li>粒子$i$当前位置为其历史最优位置，但不是全局最优位置，即<script type="math/tex">x_{id} = p_{id}, x_{id} \not= p_{gd}</script>。<br>则算法进化模式为 ：    <script type="math/tex; mode=display">v_{id}^{(t+1)} = \omega v_{id}^{(t)} + c_{1}r(p_{id}^{(t)} + rgauss_{id}^{(t)}-x_{id}^{(t)})\\
+c_{2}r(p_{gd}^{(t)}-x_{id}^{(t)})\\
=  \omega v_{id}^{(t)} + c_1r^2gauss_{id}^{(t)} + c_{2}r(p_{gd}^{(t)}-x_{id}^{(t)})</script></li>
</ol>
<p>此时GDPSO速度增量比PSO更大，其全局搜索能力更强，收敛速度更快，且高斯扰动选项能帮助算法逃离局部最优。</p>
<ol>
<li>粒子$i$当前位置为其历史最优位置，同时又是全局最优位置，即<script type="math/tex">x_{id} = p_{id} = p_{gd}</script>。<br>则算法进化模式为：</li>
</ol>
<script type="math/tex; mode=display">v_{id}^{(t+1)} = \omega v_{id}^{(t)} + c_{1}r(p_{id}^{(t)} + rgauss_{id}^{(t)}-x_{id}^{(t)})\\
+c_{2}r(p_{gd}^{(t)}-x_{id}^{(t)})\\
 = \omega v_{id}^{(t)} + c_1r^2gauss_{id}^{(t)}</script><p> 此时GDPSO速度项比标准PSO增加了一个高斯扰动值，有助于算法跳出当前局部最优解。</p>
<ol>
<li>粒子$i$当前位置不是其历史最优位置，同时又不是全局最优位置，但是粒子$i$的历史最优位置恰好是全局最优位置，即<script type="math/tex">x_{id} \not= p_{id}，x_{id} \not= p_{gd}, 且p_{id} = p_{gd}</script>。<br>此时算法的进化模式为：<script type="math/tex; mode=display">v_{id}^{(t+1)} = \omega v_{id}^{(t)} + c_{1}r(p_{id}^{(t)} + rgauss_{id}^{(t)}-x_{id}^{(t)})\\
+c_{2}r(p_{gd}^{(t)}-x_{id}^{(t)})\\
=\omega v_{id}^{(t)} + 2c_1r(p_{gd}^{(t)} - x_{id}^{(t)} + \frac{1}{2}rgauss_{id}^{(t)})</script></li>
</ol>
<p>此时，对于PSO，种群中粒子完全向当前全局最优值移动，很容易陷入局部最优值。而GDPSO一方面保证其收敛速度比PSO更快，另一方面由于增加了高斯扰动项，很好的避免了算法陷入局部最优值。</p>
<ol>
<li>粒子 $i$当前位置不是其历史最优位置，同时又不是全局最优位置，且粒子$i$的历史最优位置不是当前种群全局最优位置，即<br><script type="math/tex">x_{id} \not= p_{id}，x_{id} \not= p_{gd}，且 p_{id} \not= p_{gd}</script> 。算法的进化模式为：</li>
</ol>
<script type="math/tex; mode=display">v_{id}^{(t+1)} = \omega v_{id}^{(t)} + c_{1}r(p_{id}^{(t)} + rgauss_{id}^{(t)}-x_{id}^{(t)})\\
+c_{2}r(p_{gd}^{(t)}-x_{id}^{(t)})\\
= \omega v_{id}^{(t)} + c_{1}r(p_{id}^{(t)}-x_{id}^{(t)})+c_{2}r(p_{gd}^{(t)}-x_{id}^{(t)})\\
+c_1r^2gauss_{id}^{(t)}</script><p>此时相比于PSO的速度项，GDPSO增加了一个高斯扰动项，其可以帮助粒子扩大搜索范围，增强全局寻优能力，且提高了算法收敛速度。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><ol>
<li>选择测试函数<br>$Griewank$函数(取值范围为$[一600，600]$，理论最优值为0)：<script type="math/tex; mode=display">f(x) = \frac{1}{4000}\sum_{i=1}^{D}x_i^2 - \prod_{i=1}^{D}cos(\frac{x_i}{\sqrt{i}}) + 1</script></li>
<li>环境<br>JetBrains PyCharm + Python3.7</li>
<li>参数设置</li>
</ol>
<pre><code class="lang-python">W = 0.6  # 惯性权重，根据论文会随着迭代次数改变
C1 = 2.0  # 认知
C2 = 2.0  # 社会
P = []  # 第i个粒子搜索到的历史最优位值
Pifitness = []  # 记录第i个粒子搜索到的历史最优值
Pg = []  # 整个粒子群搜索到的最优位值
Pgfitness = float(&#39;inf&#39;)  # 记录整个粒子群搜索到的最优值
PgfitnessRecord = []
intervalMin = -600  # 种群搜索区间下限
intervalMax = 600  # 种群搜索区间上限
Vmin = -120  # 粒子的速度下限
Vmax = 120  # 粒子的速度上限
N = 10  # 粒子个数
T = 2000  # 迭代次数
D = 30  # 粒子的维度
</code></pre>
<ol>
<li>实验结果</li>
</ol>
<p><img src="../image/GDPSO_2000.png" alt="GDPSO_2000"></p>
<blockquote>
<p>GDPSO算法迭代2000次</p>
</blockquote>
<p><img src="../image/GDPSO_20000.png" alt="GDPSO_20000"></p>
<blockquote>
<p>GDPSO算法迭代20000次</p>
</blockquote>
<p>完整实验代码见我的<a href="https://github.com/lightingmoon/BlogResourceCode/tree/master/GDPSO">Github</a></p>
<blockquote id="fn_1">
<sup>1</sup>. 通讯作者：孙辉，邮箱: sunhui@nit.edu.cn<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>优化算法</category>
      </categories>
      <tags>
        <tag>PSO</tag>
        <tag>高斯扰动学习策略</tag>
      </tags>
  </entry>
  <entry>
    <title>Python append()方法与深、浅拷贝</title>
    <url>/Python-list.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　最近在用Python实现粒子群算法时，我要用列表记录粒子群算法迭代时种群的情况，但是却发生了一些问题。调试浪费了一些时间，故在此记录下来。<br><a id="more"></a></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>这段Python代码:</p>
<pre><code class="lang-python">&gt;&gt;&gt; list1 = []
&gt;&gt;&gt; list2 = [1,2,3]
&gt;&gt;&gt; list1.append(list2) # 将list2追加到list1尾部
&gt;&gt;&gt; print(list1)
[[1, 2, 3]]
&gt;&gt;&gt; list2[1] = 0        # 改变list2第二个值
&gt;&gt;&gt; print(list1)
[[1, 0, 3]]
</code></pre>
<p>　　问题是：我将list2加入到list1后面，再去改变list2第2个元素值，结果list1中对应索引位置元素也发生改变。想想粒子群算法迭代30次寻到最优值后，但种群却一直没变，诡异至极。</p>
<h3 id="深入剖析"><a href="#深入剖析" class="headerlink" title="深入剖析"></a>深入剖析</h3><p>继续看这段代码：</p>
<pre><code class="lang-python">&gt;&gt;&gt; id(list2) == id(list1[0])
True
</code></pre>
<p>　　这表明list2在内存中的起始位置与list1[0]在内存中的位置是一样的。实际上列表list1的append()方法是将list2进行浅拷贝，把list2引用直接赋值给list1[0], list2直接作为一个对象追加到list1[0]上。这样改变list2也会改变list1[0]，这就很危险了。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>　　导入copy模块，对list2进行深拷贝再追加到list1尾部即可：</p>
<pre><code class="lang-python">&gt;&gt;&gt; import copy
&gt;&gt;&gt; list1 = []
&gt;&gt;&gt; list2 = [1,2,3]
&gt;&gt;&gt; list1.append(copy.deepcopy(list2))
&gt;&gt;&gt; list1
[[1, 2, 3]]
&gt;&gt;&gt; list2[0] = 0
&gt;&gt;&gt; list1
[[1, 2, 3]]
&gt;&gt;&gt; list2
[0, 2, 3]
</code></pre>
<p>　　深拷贝即是为list2创建一个副本再追加到list1尾部，这样list2与list1[0]就不再是同一个引用了。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>list</tag>
        <tag>列表</tag>
      </tags>
  </entry>
  <entry>
    <title>关于网易云音乐外链播放器的一些问题</title>
    <url>/NeteaseMusicOutchainPlayer.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　最近想更新一下博客sidebar里面音乐插件的歌单，遇到一些问题，在以前遇到过，但是却忘了。故以防以后再忘，写下博客以记录。<br><a id="more"></a></p>
<h3 id="1-关于如何创建网易云音乐歌单外链播放器"><a href="#1-关于如何创建网易云音乐歌单外链播放器" class="headerlink" title="1.关于如何创建网易云音乐歌单外链播放器"></a>1.关于如何创建网易云音乐歌单外链播放器</h3><ol>
<li>打开网页版<a href="https://music.163.com">网易云音乐</a>，登上自己账号，并找到自己想要制作外链播放器的歌单，按以下流程来：<br><img src="image/netease1.png" width="auto" height="auto">    </li>
</ol>
<hr>
<p><img src="image/netease2.png" width="auto" height="auto">   </p>
<hr>
<p><img src="image/netease3.png" width="auto" height="auto"></p>
<hr>
<p><img src="image/netease4.png" width="auto" height="auto"></p>
<hr>
<p><img src="image/netease5.png" width="auto" height="auto"></p>
<hr>
<p>单曲外链播放器也类似。进入制作外链播放器后就按照官方教程走即可。     </p>
<h3 id="2-其中最需谨记的就是歌单里面的歌曲必须有版权可以用来制作外链播放器，如果忽视了这个，那么会产生以下两个问题："><a href="#2-其中最需谨记的就是歌单里面的歌曲必须有版权可以用来制作外链播放器，如果忽视了这个，那么会产生以下两个问题：" class="headerlink" title="2. 其中最需谨记的就是歌单里面的歌曲必须有版权可以用来制作外链播放器，如果忽视了这个，那么会产生以下两个问题："></a>2. <strong>其中最需谨记的就是歌单里面的歌曲必须有版权可以用来制作外链播放器，如果忽视了这个，那么会产生以下两个问题：</strong></h3><ul>
<li>不能制作外链播放器，提示没有版权。</li>
<li>就算制作成功了，但不能进行播放。最难受的就是你点击播放时，播放器不会进行提示。百思不得其解之时，忽然想起以前遇到这个问题。但是也浪费了好多时间。</li>
</ul>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title>致敬：高山流水</title>
    <url>/ToHailBosomFriends.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><center>《执子与通子》</center>


<blockquote>
<p>艾子游于郊外，弟子通、执二子从焉，渴甚，使执子乞浆于田舍。有老父映门观书，执子揖而请，老父指卷中“真”字问曰：“识此字，馈汝浆。”执子曰：“‘真’字也。”父怒不与，执子反以告。<br>艾子曰：“执也未达，通也当往。”通子见父，父如前示之。通子曰：“此‘直’‘八’两字也。”父喜，出家酿之美者与之，艾子饮而甘之，曰：“通也智哉！使复如执之认真，一勺水吾将不得吞矣。”</p>
</blockquote>
<p><a id="more"></a>　　</p>
<p>今日在读一本书时忽的想起了这篇故事，故事即是启迪人们智慧的。而我当时读书心有所感，在这番境地下，再忆起这个故事竟然对生而为人充满了悲哀。每个人从出生到长大都经历了迥然而异而又如许多的故事，这千千万万的故事又造就了每个人不同的内心。我们总是苦于怎样才能将内心真实的想法情感表达出来，而又限于语言这一有限工具。到现在才真是体会到了“高山流水”这一千古绝唱。还记得刘慈欣在《乡村教师》中这样描述地球交流方式：</p>
<blockquote>
<p>“他们基本特征是什么？”舰队统帅问。</p>
<p>“您想知道哪些方面？”蓝84210号上的值勤军官问。</p>
<p>“比如，这个行星上生命体记忆遗传的等级是多少？”</p>
<p>“他们没有记忆遗传，所有记忆都是后天取得的。”</p>
<p>“那么，他们的个体相互之间的信息交流方式是什么？”</p>
<p>“极其原始，也十分罕见。他们身体内有一种很薄的器官，这种器官在这个行星以氧氮为主的大气中振动时可产生声波，同时把要传输的信息调制到声波之中，接收方也用一种薄膜器官从声波中接收信息。”</p>
<p>“这种方式信息传输的速率是多大？”</p>
<p>“大约每秒1至10比特。”</p>
<p>“什么？！”旗舰上听到这话的所有人都大笑起来。</p>
<p>“真的是每秒1至10比特，我们开始也不相信，但反复核实过。”</p>
<p>“上尉，你是个白痴吗？！”舰队统帅大怒，“你是想告诉我们，一种没有记忆遗传，相互间用声波进行信息交流，并且是以令人难以置信的每秒1至10比特的速率进行交流的物种，能创造出5B级文明？！而且这种文明是在没有任何外部高级文明培植的情况下自行进化的？！”<br>……　　　　</p>
</blockquote>
<p>　　作者也在感叹人类的交流效率如此之低。尽管人类为了解决这个问题做了很多努力，比如发明了数学——这种充满理性与逻辑的语言，精妙而准确，从中甚至能抽象出一个人，乃至整个宇宙。但是到了什么时候数学也能准确地表达人类的情感呢？或许这是永远也达不到的白月光。这又凸显了心有灵犀的弥足珍贵。当能有一个人与你产生共鸣时，你就能体会到当年“伯牙绝弦”的一半决绝。我们皆感叹“落花有意，流水无情”，倒不如在心里默数十秒，为他人展现一片耐心，也让自己能更多感受对方的处境。这也是我希望自己能做到的，坚冰既融，温暖何穷？</p>
<p>　　又或许正是这样，我们才有了爱恨情仇呢？进化路上的风景精彩纷呈，每一帧图像都会让人流连忘返。你我又能贡献出怎样的故事呢？</p>
]]></content>
      <categories>
        <category>静夜思</category>
      </categories>
      <tags>
        <tag>所感</tag>
      </tags>
  </entry>
  <entry>
    <title>粒子群算法研究(2)</title>
    <url>/ParticleSwamOptimizaton1.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>接上一篇问题，运用标准粒子群算法进行求解分析:</p>
<blockquote>
<p>求函数$y=1-cos(3x)e^{-x}$在$[0,4]$上的最大值    </p>
</blockquote>
<a id="more"></a>
<p>下面是算法的参数与需要的数据结构：</p>
<pre><code class="lang-python"># 标准粒子群算法参数
W = 1               # 惯性权重
C1 = 2.8            # 认知
C2 = 1.3            # 社会
Pi = []             # 第i个粒子搜索到的历史最优位值
Pifitness = []      # 记录第i个粒子搜索到的历史最优值
Pg = 0              # 整个粒子群搜索到的最优位值
Pgfitness = 0       # 记录整个粒子群搜索到的最优值
intervalMin = 0     # 种群搜索区间下限
intervalMax = 4     # 种群搜索区间上限
Vmin = -0.001       # 粒子的速度下限
Vmax = 0.001        # 粒子的速度上限
swam = []           # 种群
ParFitness = []     # 种群适应值
ParVelocity = []    # 记录粒子i速度
N = 3               # 粒子个数
T = 30              # 迭代次数
record = []         # 记录粒子群每一代粒子群
table = []          # 记录每一代粒子群最优适应值
</code></pre>
<p>用三个一维粒子进行迭代，若粒子位置或速度超过边界，则对其重新进行初始化。下面对结果进行分析：</p>
<h4 id="迭代10次"><a href="#迭代10次" class="headerlink" title="迭代10次"></a>迭代10次</h4><hr>
<p><img src="image/PSO_10.png" width="auto" height="auto" border=0/></p>
<p><center>
1.1 粒子群最优值随迭代次数变化情况       
</center>      </p>
<hr>
<p><img src="image/PSO_iteration_10.png" width="auto" height="auto" border=0/></p>
<p><center>1.2 3个粒子迭代10次分布情况</center></p>
<hr>
<p>　　可见迭代10次，局部搜索还未能进一步发现最优值，增加迭代次数看看。</p>
<h4 id="迭代20次"><a href="#迭代20次" class="headerlink" title="迭代20次"></a>迭代20次</h4><hr>
<p><img src="image/PSO_20.png" width="auto" height="auto" border=0/></p>
<p><center>
2.1 粒子群最优值随迭代次数变化情况       
</center>      </p>
<hr>
<p><img src="image/PSO_iteration_20.png" width="auto" height="auto" border=0/></p>
<p><center>2.2 3个粒子迭代20次分布情况</center></p>
<hr>
<p>　　迭代20次粒子对局部最优进一步挖掘，得到了更好的解。</p>
<h4 id="迭代30次"><a href="#迭代30次" class="headerlink" title="迭代30次"></a>迭代30次</h4><hr>
<p><img src="image/PSO_30.png" width="auto" height="auto" border=0/></p>
<p><center>
3.1 粒子群最优值随迭代次数变化情况       
</center>      </p>
<hr>
<p><img src="image/PSO_iteration_30.png" width="auto" height="auto" border=0/></p>
<p><center>3.2 3个粒子迭代30次分布情况</center></p>
<hr>
<p>　　效果对比迭代20次并没有多大提升。当然由于目标函数太过简单，所以粒子个数及粒子的维数并不大，算法复杂度也不高。其实这样也很好，初学时从简单一点的问题着手，一点一点在解决问题中深化认识。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在编程过程中对算法理解加深了一个层次，对优化算法而言，在设计实现时要按照以下流程来：</p>
<ol>
<li>确定算法需要的参数及其数值</li>
<li>确定算法所用的数据结构以及输出</li>
<li>设计实现算法时需要的接口</li>
<li>算法主程序</li>
<li>调参</li>
<li>分析结果</li>
</ol>
<hr>
<p>　　在这里分析还是做的不是多么好，但是因为问题比较简单，没有分析价值，所以只将结果进行对比即可。整个实现的Python代码见我的<a href="https://github.com/lightingmoon/BlogResourceCode/tree/master/StandardPSOExperiment">GitHub</a></p>
]]></content>
      <categories>
        <category>优化算法</category>
      </categories>
      <tags>
        <tag>PSO</tag>
        <tag>粒子群优化算法</tag>
      </tags>
  </entry>
  <entry>
    <title>奇怪的梦</title>
    <url>/StrangeDream1.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码，查看文章。</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="5e4c05e9ea47335716d6b97e8789bebbe3866c9b28cf5b42f1712821c30b6e8a">e378a21df03967215d4882ac498a8c4747b3be56619baea1a4420b26742222c8de32b9f6d6b63cd440592388713363cb9916ae7670782d61ac60f5695b050577a219dd015e8f03fbff27ed755106c02361d8b2a6cbf20b0958dd968078430c3ae297d9dedc4f1b84597178f969b02bf778ac1bc9ad33f75cc287e60cd790fe5a78938bdf87d0ea36ec832fcb6bd68f40c3e5931712ec8eb94a535e19f45b34361af57cce7e4137bc96b5012b437a522285d45e0b59d3ac35a439a67a101a70763ac4a6a04c74e6e9943e7ff4f1a917462ee7a0a5492227393609a9dc2a75bb95c69215714473442cfb77803bd24e009045ce20edc8d75afed8579728d8bf8bec81ffcf64b3ac2f52e7ff4c7c939f3378f58bf577967ef5f76dc300768ea020a7d769e6d311baae243868cec89cb44088b766d981b2ac1f87dcbc96125a228d62f60c05c8a434efa218750b5c5648e98c23dd716be2cfba45e06d6443d45d9e27769a3c0620a88b971190e038852a272bfde209ae7595416fe212b17176db79ffb7b6925787aa6badd82f1f6ec1b2f3f66b2592f6ca9f2de137824ec12e8435948a8628460bd56939e1267e03bfc969973734cd4790c09f180a3738ec40efe3943a4f9fa217e32c98ff6b179c2338aa8db0cba387fb1cab5d604ee3dda3bfe1f425234c6414478b5bf7b9db605301ed4754dd573c17db14b6c3a4a1ad5d4579dc10909abe789bb4f2d8fcca3969c4412f0edbf2a1372c22849ade92a9fb13547130a5e5ded2a9676fc1e53902192c17f98189bead8320f6746659e85edeb7cbed43dd4815d1844a76be12944c414864926d93bd73b0497210569c9c2436cb471dc7aaca871faf9fa5c02b0f20de8b2b953fc6dc8dd6fed8075d13bd0a4b75cbed3a122760c995ff9ab65be80e00edfa6f7a6d751c7f09b1be34ba196f1a7ebd3143ed166de7d29180b3909dbbd305e8993d00c987a215a4f5ac25baf0d30926de5c56d4b9a9c7664fce66e68d296fc4fc9c8013f76a2823e5cf273ecd11c84c880e9e00535f46ac91c779852f919f0c779cc6945f4284f2bc4da2ad0f9a7746f6d11e07329e308a1b0a7f07b55b6fb537bdcd3f98a2a940a691e3132ce86f10af3d9bae757e357a267f2c4707a529c07c5c0ad95b3d7ef3070258d5b8f34749eb82f2e3a57392f756590f379b546aadfc6b8c79fd9c4002ff226d8bd7e11533589d76dd5103ad841febb86990891440367f54ac37d48f2ef728b5ae11875a4ebc0986ef857c56d12b9f72a5aad952e1cc47969a85cd594a949c7543b6f1f471efd1a259aed5a0b687f91551f51f163d3ce9add0fe312a3ad2a9b7672468fb28cda4cb0bb779ff6f77c0db1975e5549fefe789dc87249c9cae0b4e0fdda2ffa6fb88b7a6bb6786a3268b873a01cffa2c9b03e3b2fec7179a91fe80e652becb84f76d08d222089ba839e20394daf649b4e0b76acbd8a310ff84fe7ada1f49bcb6c873a0f9214bffb3df9d9208b05f127ca677fcfdbe1dc3a01db973ba2684d5b0e13835c165548c139abcd548ede7d835ceae9e3ebcd43f29cb96965b5a522c94b012f443eb95f6960600abbb23fe2a0395cf2dff277394b471f1e403067042f39f6d47b4fe65740e1e880280acb455b01d6ab5721a10d81b2a1a13d0dc4d9e3b34f335cb7bd2c25809aa5996caa3673b3b060eebf7cb0546b29f1289dd216c944262ed071775f276ec74fd354ed6ebffea1a288b56ae9f50a8f681b0c3e3755d2ae7154ef86e852b8c2d8d579d9eb1a9f68a2e697ed8f28d4e22b5040e5ae685d2bde8420791d029c1a1f93c2be635e2477e56920ed6fa60b30b5ac0855d77df54c400f6e77511aed2f57bb1a13d8ce553a9553388da2bb7a9efb3735a6ee1def88e49b8f9fb0719ba62e7643f20caad6d7924f6ae84663e96736da052093f4805282db9a3e499fa358e1362da5fee1bf8f8ded7d0c8933405ec50c0d0b268c7e87ba41f25d3cae587f2989c643730ba6ac03f3a1bac6fd08c2862253aa54900a2a78626ffcb9e15bcd2eefb5c5072367acf998e314571296925d83b71cec190c3292a87ce02fb298ba7eef3f0097f394da4209bbd647e444d88a91cfac31380f1fff64c51389e792acbd75904fe7686bd3f47be2cb9622535b15ae9d91b83c2bddf801afd262f2a27c96fa9bf3887bd7fbe1385c90e5071271f9c4b8212cc856415b582f5c3b35c114178c2f5d5223fbee45ea900dffbb38d7acb505c4f36b112f91ba6ebf6d23fc9e7120ee3734d02d9e0a81a4c3c590389bd0d1d3c3e19b737f739365143d04f611aa26fe3d85827891a2a564c4b0efd19ad7d2caea414bbd8aaf26933ca05b6a3022eb3085c25db4d4fc71d6795f16e0afb34ea5e9e60c5415a303c001a6fc0b34e46ba66fdfeb0aeaa609e90047e72e1d956a08179a92877c72316dd9be6cc1e75b376dc9aa1172e02e367e0780fc00c90cd64e0c1c69d5bb405ea7a08494d5c3af6e301fc3f0620bb98be35f9d4d5921764d3ddb64ae68c31bb141d03c9d6209e9d8c5c2ede998090561aa0e2e7639b74ca7e6246cb02ead42757816505e4038cf484e4c4b2ecf9f3758378be86d810bea94598699255d3b9d614497d69a763564da48bf280fd896280abfde9bb5cb41f6e5dbcfbe462b53eae0fa8f67ca1ff90d40067ddec501371a73bac123b0bb3bc86fa7ee3139b62ff51422c12d1e7720e5b4d3222e9a5637c1e486e7e772e3ddd5f3302d266257466f63b90e00aebe5d62c4b2340ed43452d7499f9b978be8365547c88ea8f39ddd063b19cad7279954d496b795a09b5593b2611e9d6077d2800c2e2a8845c2fc9c0204d66328415258847bc14ffddf6778d273cebf894a0999547d1a848a025515f4c307be4bc184f8f1cf8b5c4551332f9df4db9cc280a7717f162fa91d155fa3fd95048e55201044b5102f4ef12c66d745056caf57df00fefb62fdbb4ae8191dcf27f51f2939c24374748950b66f21ffa64f08928ec6f5518828118c58d1278a540ff701edf5e90c9888ed6092f9e00a83da886a551f3ea263b34c0b34fb625c1aa2fb96b5043ba06c9c2c81a2db58653356e004188453eaa116e355237eba76aed33035f148ee33576da4005344357ccad5be3f4c9ca582bc79cb6f1cb9211e337215b27f6f6c8a7ed78cfbf5eee9bcebcb8e8efa2f100f631bd9e434eb5b7207aefec45b42ec0b30c8244f47273d6474a8fba575adc1be54fd91fef6bb15c824aef0600ba714b81428807efba05160e22ea498f213b3891c0e65cfff6f1f34ff899802db5beae427d073304e600279149fc9d28bc9d4a2b281d8c7d6ae28d770d233ba227b649b1cb034dd6276a21b7987544df5e3a6adfd050f6d70aaacade46a17634b2ad1c9bd117bb8e37644f7f5676c681275102b2bdf6b7d98ccfe0e7ce6f746aba5a6ed50d5e340481ede7977c42a7758cae580a1c98c4686edcf4d03af486381bea93f8faf2f1610f58bff9fede05b05ce27e9ae64fca87fed6820d52366c3dec2e00cde6020af9134adb72dfe606786ecbe54fcb2274421271a4a785d2a5cd1c2bffd6e36a4409aedbd23919ca7d95679d8b6fe186104c535f34cdb65fb1b29798b72664ca913983c6fc262a4dabb94c81198b4e8f85fe3d51802c6395388c48c50d0b53e8e95fe466be56eb75cd2c32f227491d612ec29a442a6d4031ab9fe09d0310cfbec2925bc166a3a19087509a388498d39a4286d21dfd802b0dfc8c39405741c06ebe3c0beac7</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>述梦</category>
      </categories>
      <tags>
        <tag>梦的救赎</tag>
      </tags>
  </entry>
  <entry>
    <title>粒子群算法研究(1)</title>
    <url>/ParticleSwamOptimization.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　粒子群算法（ Particle Swarm Optimization, PSO）是由Eberhart和Kennedy于1995年提出，它的基本概念源于对鸟群觅食行为的研究。设想这样一个场景:一群鸟在随机搜寻食物，在这个区域里只有一块食物，所有的鸟都不知道食物在哪里，但是它们知道当前的位置离食物还有多远。那么找到食物的最优策略是什么呢?最简单有效的就是搜寻目前离食物最近的鸟的周围区域。<br><a id="more"></a><br>　　PSO算法就从这种生物种群行为特性中得到启发并用于求解优化问题。在PSO中，每个优化问题的潜在解都可以想象成d维搜索空间上的一个点，我们称之为“粒子”（Particle），所有的粒子都有一个被目标函数决定的适应值(Fitness Value )，每个粒子还有一个速度决定他们飞翔的方向和距离，然后粒子们就追随当前的最优粒子在解空间中搜索。随着位置更新（迭代次数）增加，粒子最终在搜索空间上收敛于最优值（理想状态下）。    </p>
<h3 id="标准粒子群算法（全局版本）"><a href="#标准粒子群算法（全局版本）" class="headerlink" title="标准粒子群算法（全局版本）"></a>标准粒子群算法（全局版本）</h3><p>　　例如，求函数$y=1-cos(3x)e^{-x}$在$[0,4]$上的最大值，并在[0,4]之间放置了两个随机的点，假设为$x_1=1.5,x_2=2.5$，则$x_1,x_2$为标量。对于高维情况，比如二维，求$z=2x_1+{x_2}^{2}$，此时每个粒子都是二维的，记</p>
<script type="math/tex; mode=display">P_1=(x_{11},x_{12}),P_2=(x_{21},x_{22}),...,\\ 
P_n=(x_{n1},x_{n2})</script><p>这里$n$为粒子群群体规模，也是粒子个数，每个粒子维数为2。更一般的粒子维数为q，则这个种群中有n个粒子，每个粒子为q维。<br>　　对由n个粒子组成的Q维空间进行搜索，第i个粒子表示$x<em>i=(x</em>{i1},x<em>{i2},…,x</em>{iq}), i=1,2,…,n$，其在各个维度上速度表示为$v<em>i=(v</em>{i1},v<em>{i2},…,v</em>{iq})$，每个粒子在搜索时考虑以下两个因素：</p>
<ol>
<li>自己搜索到的历史最优值$p<em>i, p_i=(p</em>{i1},p<em>{i2},…,p</em>{iq}),i=1,2,…,n$</li>
<li>全部粒子搜索到的最优值$p<em>g, p_g=(p</em>{g1},p<em>{g2},…,p</em>{gn}), i=1,2…,n$<br>下面是粒子在搜索时位置速度更新公式：<script type="math/tex; mode=display">v_{id}^{k+1}=\omega v_{id}^{k}+c_1(p_{id}^{k}-x_{id}^{k})\\
　　+c_2(p_{gd}^{k}-x_{id}^{k})</script><script type="math/tex; mode=display">x_{id}^{k+1}=x_{id}^k+rv_{id}^{k+1}</script>其中的参数：</li>
</ol>
<ul>
<li>$w$为保持原来速度的系数，即惯性权重，其值非负。当值较大时，全局寻优能力强，局部寻优也就弱了；其值较小时，局部寻优能力强，全局寻优能力弱。</li>
<li>$c_1$是跟踪自己历史最优值的权重系数，表示粒子自身的认识，所以叫“认知”，通常设置为2</li>
<li>$c_2$是粒子跟踪群体最优值的权重系数，表示粒子对整个群体知识的认识，叫“社会知识”，经常叫做“社会”，通常设置为2</li>
<li>r 是对位置更新的时候在速度前面加的一个系数，这个系数被称为约束因子，通常设置为1<br>　　这就是一个标准的粒子群算法<br>　<center><img src="image/PSO.png" width="217" height="414"/></center><br>其中<strong>终止条件</strong>可以为适应值到达一定数值或循环一定的次数。因这里的粒子同时跟踪自己的历史最优值和群体最优值来改变自己的位置预速度，所以又叫做<strong>全局版本的标准粒子群</strong>优化算法。</li>
</ul>
<h3 id="标准粒子群算法（局部版本）"><a href="#标准粒子群算法（局部版本）" class="headerlink" title="标准粒子群算法（局部版本）"></a>标准粒子群算法（局部版本）</h3><p>如果改变全局版本的速度更新公式，让每个粒子位置速度更新根据：     </p>
<ul>
<li>粒子自己搜索到的历史最优值$p_i$</li>
<li>粒子邻域内搜索搜索到的最佳值$pn_{k}$<br>其余保持不变，则就成了<strong>局部版本的粒子群算法</strong>。<br>　　一般一个粒子$p_i$的邻域随着迭代次数增加，第一次迭代时，其邻域为0，随着迭代次数邻域线性变大，最后扩展到整个粒子群，这时就变成了全局版本的粒子群算法了。实践证明：<br><strong>全局版本的粒子群算法收敛速度较快，但容易陷入局部最优解；而局部版本的收敛速度慢，但是不容易陷入局部最优。故现在粒子群优化算法大都在<em>收敛速度</em>与<em>摆脱局部最优</em>之间做权衡。</strong><h3 id="静态邻域："><a href="#静态邻域：" class="headerlink" title="静态邻域："></a>静态邻域：</h3>按照粒子的编号取粒子的邻域</li>
<li>环形</li>
<li>随机环形</li>
<li>轮形</li>
<li>随机轮形<br>　<center><img src="image/PSONeiborhood.png" width="388" height="394"/></center></li>
</ul>
<ul>
<li>环形取法如上<strong>图1</strong>中:<br>　　对编号为1的粒子来说，当粒子邻域个数k为0时，则邻域是其本身；粒子邻域个数k为1时，则其邻域为{2,8};粒子邻域个数k为2时，其邻域为{2,8,7,3}…当邻域个数为4时，粒子的邻域就为整个粒子群了。</li>
<li>轮形取法如上<strong>图3</strong><br>　　对于指定粒子i，其位于邻域中心，其它粒子以一定规则与粒子i相连。只有中心粒子与其它相连粒子进行信息交换，中心粒子通过比较邻域中所有粒子携带信息而向其中最优粒子靠近。同时，邻域内最优信息通过中心粒子的性能改善而传播到种群的其它粒子。因此，中心个体令较好信息在种群中的传播速度变慢而增大了全局搜索能力，不至于早收敛。<h3 id="动态邻域"><a href="#动态邻域" class="headerlink" title="动态邻域"></a>动态邻域</h3></li>
</ul>
<ul>
<li>按照粒子的欧式距离取粒子的邻域<br>　　记录任何两个粒子间最大距离为$d_m$,对每一粒子按照$\frac{||x_a - x_b||}{d_m}$,其中$||x_a-x_b||$为粒子a与粒子b的欧氏距离。而选择阈值$frac$根据迭代次数而变化，当另一粒子b满足$\frac{||x_a-x_b||}{d_m} &lt; frac$，认为b是当前粒子的邻域内。由于要计算所有粒子之间的距离，计算量大且需要很多额外的存储空间，所以该方法不常用。<br>参考文献：</li>
<li>[1]李丽,牛奔.[M]粒子群优化算法.北京:冶金工业出版社,2009</li>
<li>感谢这位前辈13年前的博客<a href="https://blog.csdn.net/niuyongjie/category_294976.html">niuyongjie</a>引我入门。</li>
</ul>
]]></content>
      <categories>
        <category>优化算法</category>
      </categories>
      <tags>
        <tag>PSO</tag>
        <tag>优化算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1003 Emergency😏</title>
    <url>/1003-Emergency.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　DFS活络思维一下。<br><a id="more"></a><br>    As an emergency rescue team leader of a city, you are given a special map of your country.<br>    The map shows several scattered cities connected by some roads.<br>    Amount of rescue teams in each city and the length of each road between any pair of cities<br>     are marked on the map. When there is an emergency call to you from some other city,<br>    your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p>
<pre><code>Input Specification:
Each input file contains one test case.
For each test case, the first line contains 4 positive integers:
N (≤500) - the number of cities (and the cities are numbered from 0 to N−1),
M - the number of roads, C1 and C2- the cities that you are currently in and that you must save,
respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city.
Then M lines follow, each describes a road with three integers c1, c2 and L,
which are the pair of cities connected by a road and the length of that road, respectively.
It is guaranteed that there exists at least one path from C1 to C2.

Output Specification:
For each test case, print in one line two numbers:
the number of different shortest paths between C1 and C2,
and the maximum amount of rescue teams you can possibly gather.
All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.
Sample Input:
5 6 0 2
1 2 1 5 3
0 1 1
0 2 2
0 3 1
1 2 1
2 4 1
3 4 1   
Sample Output:
2 4  
作者: CHEN, Yue
单位: 浙江大学
时间限制: 400 ms
内存限制: 64 MB
</code></pre><p>思路提点:<br>　　考虑DFS，从指定城市$c_1$出发，依次访问邻接城市，直到目标城市$c_2$。用$LL$记录到达目标城市最短路径长度，$L$记录当前长度；$gather$记录最短路径最多的援救队，$gt$记录当前路径援救队，shortest记录最短路径条数。每次访问到目标城市就对$LL,gather,shortest$进行更新。之后进行回溯继续搜索。C++代码如下：</p>
<pre><code class="lang-C++">#include&lt;iostream&gt;
#include&lt;array&gt;
using namespace std;

const int INF=0x3fffffff;
array&lt;array&lt;int,507&gt;,507&gt; pic;
array&lt;int,503&gt; team;
array&lt;int, 507&gt; vis;

// 结果
int shortest,gather=0;
// DFS信息
int LL=INF;    //
int L=0;
int gt;

void DFS(int v, int d, int n)
{
    if(v == d)
    {
        if(L &lt; LL)        // 找到比之前路径更短路径，最短路径条数置1，更新最短路径长度
        {                // 更新最多搜救队数目
            shortest = 1;
            LL = L;
            gather = gt;
        }
        else if(L == LL)    // 不止一条最短路径，更新最多搜救队数目
        {
            shortest++;
            gather=max(gather, gt);
        }
        return;                // 返回
    }

    vis[v]=1;   //置访问标记
    for(int i=0; i&lt;n; ++i)
    {
        if(pic[v][i]!=INF &amp;&amp; vis[i] == 0)
        {
            L += pic[v][i];
            gt += team[i];

            DFS(i, d, n);

            gt -= team[i];
            L -= pic[v][i];
        }
    }
    vis[v]=0;   // 回溯取消标记
}
int main()
{
    ios::sync_with_stdio(0);

    int n, m, c1, c2;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;c1&gt;&gt;c2;
    for(int i=0; i&lt;n; ++i)
        cin&gt;&gt;team[i];

    for(int i=0; i&lt;n; ++i)
        pic[i].fill(INF);

    int t1,t2,s;
    for(int i=0; i&lt;m; ++i)
    {
        cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;s;
        pic[t1][t2]=pic[t2][t1]=s;    // 无向图！
    }

    vis.fill(0);
    gt = team[c1];            // 源城市援救队数目

    DFS(c1,c2,n);

    cout&lt;&lt;shortest&lt;&lt;&#39; &#39;&lt;&lt;gather&lt;&lt;endl;
    return 0 ;
}
</code></pre>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>回望</title>
    <url>/Lookbacktothepast.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　20190317-20191222，一段历程，一点感动。新近读了刘慈欣的《球状闪电》，里面提到了一种人生观，让我衷心的赞同。人这一生有一种活法，就是从始至终对某种事物着迷，也就是这种东西值得自己一生为之付出而不求有所收获。我应当是寻找到了。只需要再具体一些，将之化成无数的计划和目标。<br>　　辩证唯物主义告诉我们，要有目的有计划的活着，才能在这个<strong>客观世界</strong>活得游刃有余。<br><a id="more"></a><br>　　在过去的308天里，在我的认识里，我应该是全身心的投入到了这件事中，不管结果如何，这只是自己应得的(deserve it)。下面的总结分为两部分，一部分是知识，一部分是认识。对应学与思。</p>
<h2 id="学"><a href="#学" class="headerlink" title="学"></a><strong>学</strong></h2><p>​    总结也就是“背目录”了，但是背目录也不仅仅是背目录，而是无限的回忆目录项下的知识细节，形成体系。古语“将一本书学薄”即是此道理。但是还是<strong>实践</strong>出真知。</p>
<h4 id="高数部分"><a href="#高数部分" class="headerlink" title="高数部分"></a>高数部分</h4><ol>
<li>高等数学<ul>
<li>函数（初等函数，性质（定义域，值域，对应法则.映射，周期，奇偶） 极限（无穷小，无穷大，等价、同阶、高阶无穷小，单调有界、夹逼定理） 连续定义（间断点第一类、第二类）</li>
<li>一元函数微分学（导数和微分关系，$\Delta y=f^\prime(x)\Delta x+o(\Delta (x))$，常用函数微分，高阶导）</li>
<li>一元函数积分学（积分定义，不定积分，定积分，牛-莱公式，积分上限函数，多重积分，几种坐标系（极坐标系，柱面坐标系，球面坐标系））</li>
<li>空间解析几何（向量，向量内积、外积，混合积，空间直线、平面及其表示方式，旋转曲面）</li>
<li>多元函数微分学（多重极限，微分形式不变性，隐函数存在定理，梯度，多元函数极值（AC-$B^2$），条件极值（拉格朗日函数，在SVM公式推导中有运用）)</li>
<li>正项级数（正项级数，阿贝尔定理，级数判敛(级数收敛的必要条件)，正负交错级数(莱布尼茨定理)，将函数展开成幂级数，求正项级数和函数，傅里叶级数，狄利克雷定理）</li>
<li>微分方程（一阶线性微分方程，齐次方程，贝努利微分方程，欧拉微分方程，高阶微分方程）  </li>
</ul>
</li>
<li>线性代数<ul>
<li>行列式（行列式性质六条，行列式求值，克拉默法则）</li>
<li>矩阵与向量(组)（矩阵性质、运算，初等变换，分块矩阵，矩阵的伴随，矩阵的逆，向量组线性无关相关，极大无关组，向量组的秩，向量组等价，矩阵秩，矩阵等价）</li>
<li>线性方程组（齐次方程组及其解的结构，非齐次方程组及其解的结构，同解方程，方程的公共解，方程的解空间，解空间的基，正交基）</li>
<li>特征值与特征向量（$AP = \lambda P$，正交变换，矩阵相似及相似对角化，矩阵相似的四个必要条件，实对称矩阵，向量的坐标及过渡矩阵）</li>
<li>二次型（二次型概念(令二次型系数矩阵为A，令$\vec x = (x_1,x_2,x_3,…,x_n)^T,f(x)=\vec x^TA\vec x$)，正负惯性指数，二次型合同，二次型正定的充分条件）</li>
</ul>
</li>
<li>概率论与数理统计<ul>
<li>古典概型，全概率公式(先验)，贝叶斯公式(后验)</li>
<li>随机变量函数（随机变量函数性质，离散型常用随机变量函数(两点分布，二项分布，几何分布，超几何分布，泊松分布)，连续型常用随机变量函数(均匀分布 ，指数分布，正态分布)，多位随机变量函数）</li>
<li>数理统计基础（数字变量的基本特征(期望、方差、协方差、相关系数$\rho$)，n阶中心矩，n阶原点矩）</li>
<li>参数估计（矩估计，最大似然估计，区间估计(1-$\alpha$置信区间)）</li>
<li>假设检验(弃真，纳伪假设)       </li>
</ul>
</li>
</ol>
<h4 id="专业课部分"><a href="#专业课部分" class="headerlink" title="专业课部分"></a>专业课部分</h4><ol>
<li>数据结构{逻辑结构{线性结构，非线性结构}，存储结构{顺序，链式，索引，散列存储结构}}<ul>
<li><em>线性表</em>(分别只有一个前驱和后继，对应的存储结构就是顺序表和链表，对顺序表和链表的操作，以及对应时、空间复杂度)</li>
<li><em>栈和队列</em>（其是一种逻辑结构，其中栈对元素的添加和删除仅能在一端进行，队列是只能在一端进另一端出。其存储结构可以用顺序表和链表实现）</li>
<li><em>串</em>(主要是KMP算法)（其本质就是线性表，但是其每一个元素都是字符，对串的各种操作，以及串的模式匹配）</li>
<li><em>树</em>（一个前驱，多个后继，树的性质，树的存储结构-顺序表、二叉链表，主要是二叉树，二叉树的遍历{递归，非递归}，线索树(将树线索化，可以对树逻辑上进行线性结构的访问元素)，哈夫曼树）</li>
<li><em>图</em>（有多个前驱，多个后继，图的性质，图的存储结构-邻接矩阵、邻接表，对图的遍历，图的最小生成树{Prim算法(加点、适合稠密图)、Kruskal算法(加边、适合稀疏图)}，最短路径算法(Dijkstral算法，Floyd算法)）</li>
<li><em>排序</em>（算法基本性质{确定性&amp;可行性&amp;有穷性&amp;输入&amp;输出}，时空复杂度，插入类{插入排序，希尔排序}，交换类{冒泡排序、快速排序}，选择类{选择排序、堆排序}，归并排序，基数排序，外排序(最小归并树，败者树)）</li>
<li><em>查找</em>(二叉查找树，二叉平衡树{LL,RR,LR,RL旋转}，哈希查找{建表、冲突避免(线性探测法/平方探测法/二次散列法/链地址法)}，B树(k叉平衡树))</li>
</ul>
</li>
<li>操作系统<ul>
<li><em>操作系统的更迭</em>{单道批处理-&gt;多道批处理-&gt;分时操作系统-&gt;实时操作系统-&gt;分布式操作系统{重在协作解决问题，负载均衡}-&gt;网络操作系统{重在资源共享}}</li>
<li><em>处理机管理</em>{进程定义，PCB，状态转换图，三级调度{高级调度/作业调度、中级调度/进程对换、低级调度/进程调度}、线程{CPU调度的最小单位/共享进程空间}、多线程模型{用户级线程、内核级线程}}</li>
<li><em>内存管理</em>{内存管理意义、<strong>局部性原理</strong>{贯穿计算机科学始终，分为空间局部和时间局部}，程序的编译执行过程{源代码编译-&gt;链接-&gt;装入(程序逻辑地址形成)-&gt;运行}，内存分配方式{①连续和②非连续}，①(单一连续分配{效率低，仅支持单进程系统}，固定分区分配，动态分区分配)，②(分页式分配，分段式分配，段页式分配)，虚拟存储器{逻辑上扩充内存空间，配合请求分页式内存管理}（对换性，多次性，虚拟性），页置换算法{最佳置换算法，FIFO算法，LRU算法，CLOCK算法，内存块分配策略{固定分配局部置换，可变分配全局置换，可变分配局部置换}，页工作集(驻留集){为在某一段时间间隔内，进程要访问的页面集合}}</li>
<li><em>文件管理</em>{文件的逻辑结构(顺序文件，索引文件，索引顺序文件)，文件目录(一级目录、二级目录、树形目录)，文件共享方式{索引节点(硬链接)}，文件物理结构(连续文件，链接文件，索引文件)，文件访问控制{基于角色模型访问控制}，文件管理系统{分层}，磁盘管理{磁盘调度算法}，}</li>
<li><em>设备管理</em>{功能{用户层，设备无关层，驱动层，硬件层}，I/O缓冲技术{单缓冲，双缓冲，循环缓冲}，I/O子系统{总线型，通道型，控制器型}，虚拟设备{其就是在独占型设备与进程之间增加一个共享型设备作为过渡。即进程在占用CPU时尽可能减少等待I/O的时间。SPOOLing系统{对虚拟设备技术的应用，在磁盘开辟一个独立空间暂存数据，等设备空闲再将数据送给设备。输入设备-&gt;假脱机输入程序-&gt;输入井(管理程序)-&gt;逻辑设备管理-&gt;用户进程-&gt;逻辑设备管理模块-&gt;输出井(管理程序)-&gt;假脱机输出程序-&gt;通道-&gt;输出设备}}}</li>
</ul>
</li>
<li>计算机网络  <ul>
<li><em>OSI参考模型、TCP/IP参考模型</em>{计算机网络基本功能-数据通信、资源共享，服务，协议，接口定义以及之间关系，OSI自顶向下{应用层-&gt;表示层-&gt;会话层-&gt;传输层-&gt;网络层-&gt;数据链路层-&gt;物理层}，TCP/IP{应用层-&gt;传输层-&gt;网际层-&gt;数据链路层}，分层既明确了分工，又简化了协议设计。各层通过访问下一层的SAP获得下一层的服务。}</li>
<li><em>物理层</em>{与传输介质无关，该层为设备之间数据通信提供传输媒体与互连设备，为数据链路层提供一条稳定的传输比特流线路。其接口特性是机械的(接口形状尺寸)、电气的(接口电缆电压范围)，功能的(对应电平的电压的意义)，规程的(不同功能的可能事件的时序)，物理层设备{放大器，hub(一个冲突域)}}</li>
<li><em>数据链路层</em>{访问物理层的服务为网络层提供服务，定义数据如何传输，功能:帧定界{字节计数，字符/比特填充首尾定界符，违规编码法}，差错控制{奇偶校验，循环冗余，海明码}，流量控制{因为发送时接收方处理速度和缓冲区有限，若发送方发送过快会而接收方不能以同样速度接收，则不能正确的传输数据，所以要进行流量控制，即控制发送速度。滑动窗口协议(停-等协议、后退N帧、选择重传)}，链路管理{为面向连接的服务提供链路管理}，局域网{网络拓扑逻辑上是总线型结构，其代表即是以太网的应用}，LLC子层和MAC子层{主要是MAC子层，在传输介质时涉及对传输介质的访问，以避免产生冲突。ALOHA协议，纯ALOHA协议，时隙ALOHA，CSMA协议，CSMA/CD(应用有线网)，CSMA/CA(应用于无线网)，二进制指数退避算法}，数据链路层协议有PPP协议、HDLC协议，以太网协议等。数据链路层设备{透明网桥、源路由网桥，交换机}，数据链路层设备仅能分割冲突域}</li>
<li><em>网络层</em>{网络层提供主机到主机服务，异构网络，自治系统，IPV4/IPV6，网络前缀/路由聚合，子网划分，路由转发原理，动态路由算法{距离向量算法(RIP协议，BGP协议)，链路状态路由算法(OSPF协议)}，网络层协议{IP，ARP/RARP，ICMP}，网络层设备{路由器，分为存储转发式和直通式}，网络层设备可以分割冲突域和广播域}</li>
<li><em>传输层</em>{传输层提供端到端服务，其功能主要有分用和复用。复用{在发送端多个应用可共用传输层服务}，分用{在接收端，传输层会根据端口号将数据分给不同应用}，UDP协议{面向无连接，所以其提供的服务是不可靠的，传输单位是报文，其中头部开销为8字节，数据不会进行拆分和合并}，TCP协议{面向连接，其头部至少20字节，提供可靠交付服务，其是面向字节流的，狭义上其为数据包中每个字节编号。提供全双工通信}，TCP拥塞控制{慢开始算法，拥塞避免算法，快重传算法{接收方收到失序报文段就立即向发送方发送一个ACK，告诉发送方自己收到一个失序报文并告诉对方自己需要接收的sep}，快恢复算法{连续收到同一分组的3个确认应答}}，}</li>
<li><em>应用层</em>{其直接为应用程序提供常见的网络应用服务，DNS{提供域名解析成IP地址服务，递归解析，迭代解析}，FTP{在传输层TCP上，在主动模式下，用熟知端口20作为数据端口，端口21作为控制端口，这样将数据和控制分开可以简化协议的设计}，SMTP{简单邮件传输协议，通过Push操作使用SMTP将邮件发送至邮件服务器，邮件服务器解析接收方邮件服务器地址，再通过SMTP将邮件发送至对方邮件服务器地址，接收方再通过Pull操作使用POP协议获取邮件}，HTTP{基于传输层TCP，其是一个简单的、无状态的、面向对象的请求-响应协议，请求方式主要有GET和POST,消息头部都由ASCII形式给出}}     </li>
</ul>
</li>
</ol>
<h2 id="思"><a href="#思" class="headerlink" title="思"></a><strong>思</strong></h2><p>　　在我沉浸在早出晚归这段日子里，唯孤单作陪，幸有音乐为伴。总是以为自己在想象之中，却不知世事总是发展至意料之外。我以为自己能一天精力高度集中学习14h+，以为自己在对知识宏观把握之后能无限推导细节，以为逻辑推导能代替死记硬背…大错特错。    </p>
<ol>
<li>应试教育里，你不仅要对这个知识点熟练到无以复加，其中的一些推导也必须要烂熟于心，而不是考试现场推导，在考场短短几小时里，已经不允许自己去推导回忆知识点。此错误一。</li>
<li>我总是疏于对细节知识的熟练掌握，总是想在宏观层次掌握，企图总结一条更加抽象的逻辑贯穿其中。殊不知宏观的认识是建立在对细节知识掌握之后的，类似于无限风光在险峰。在半山腰是永远也无法领略到山顶的风光的。</li>
<li>总是给自己找借口说服自己，妥协。久而久之就习惯了。有些事可以找理由说服自己，有些则不然。关键是认识到不到位。</li>
<li>不要低估自己，也更不要高估自己。</li>
</ol>
]]></content>
      <categories>
        <category>静夜思</category>
      </categories>
      <tags>
        <tag>反思</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理和词法分析器</title>
    <url>/CompilerPrinciple-preProcessAndLexAnalysis.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>结合课程实验和课程设计，时间跨度为一个月，完成预处理，词法分析器。(词法分析器已作为JavaSwing项目上传至<a href="https://github.com/lightingmoon/My-project">GitHub</a>。)<br><a id="more"></a></p>
<h3 id="预处理程序"><a href="#预处理程序" class="headerlink" title="预处理程序"></a>预处理程序</h3><pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;fstream&gt;
using namespace std;

void processSpace(ifstream &amp;fin, const char);    // 处理空格
void processMargin(ifstream &amp;fin, const char);    // 处理注释
void processCrLf(ifstream &amp;fin, const char);    // 处理回车换行
int main()
{
    ifstream fin(&quot;F:\\CompilerPrinciple\\Test1\\demo.cpp&quot;, ios::in);    // 预处理源代码文件
    freopen(&quot;F:\\CompilerPrinciple\\Test1\\out.cpp&quot;,&quot;w&quot;,stdout);    // 输出结果文件
    char now, last;
    fin.get(last);

    while(!fin.eof() &amp;&amp; isspace(last))    // 一个字符测试空文件
        fin.get(last);
    fin.unget();
    while(!fin.eof())
    {
        fin.get(now);
        switch(now)
        {
        case &#39; &#39;:
            processSpace(fin, last);
            fin.unget();    // 超前搜索回退
            break;
        case &#39;/&#39;:
            processMargin(fin, last);
            break;
        case &#39;\n&#39;:          // 只存在Mac和windows下\r\n,\r
            processCrLf(fin, last);
            last = &#39;\n&#39;;
            break;
        case &#39;\t&#39;: break;
        default:
            putchar(now);
        }
        last = now;
    }
    return 0;
}
void processSpace(ifstream &amp;fin, const char st)
{
    /*         一.去多余空格:
    *            1.判定当前字符，是空格则转第二步；否则输出
    *            2.判定记录的上一个字符，如果是换行符，则是行首空格，不输出；
    *                   如果是赋值号，则是多余空格，不输出
    *                   继续判定下一个字符，如果是斜线，则是行末与注释间的空格，不输出
    *                   如果是分号，则是行末多余字符，不输出。
    *                   如果是空格，则是多余空格，不输出
    */

    char next;
    fin.get(next);
    while(!fin.eof() &amp;&amp; isspace(next))  // 去多个连续空格
        fin.get(next);
    if(st != &#39;\n&#39; &amp;&amp; st != &#39;=&#39;
        &amp;&amp; next != &#39;/&#39; &amp;&amp; next != &#39;;&#39; &amp;&amp; next != &#39;=&#39;)
        putchar(&#39; &#39;);
}

void processCrLf(ifstream &amp;fin, const char st)
{
    /* 二. 去回车换行
    *    1.超前搜索：如果下一个字符不是换行符，为Mac下源文件，回退文件指针，输出一个空格。否则
    *      不回退，输出一个空格
    *   考虑到兼容性，windows下\r\n，unix下 \n ，Mac下是 \r，过滤
    */
    char next;
    if(!fin.eof())
    {
        fin.get(next);
        if(next != &#39;\n&#39;)
            fin.unget();
        putchar(&#39; &#39;);
    }
}

void processMargin(ifstream &amp;fin, const char st)
{
    /*          三. 去注释
    *             1.判定当前字符是否为  / ，是则进入第2步；否则输出
    *             2.超前搜索下一个字符是否为  / ，是则为单行注释，直接结束本行；否则转第3步
    *             3.超前搜索下一个字符是否为  * ，进入下一次循环，转第4步
    *             4.判定当前字符是否为  *  ，是则进入第5步；否则放弃当前字符，进入下一次循环
    *             5.超前搜索下一个字符是否为 &#39;/&#39;，是则结束循环退出子程序；
    *               否则进入下一次循环，转第4步
    */
    char next, now;
    fin.get(next);
    if(!fin.eof())
    {
        if(next == &#39;/&#39;)     // 单行注释
        {
            while(!fin.eof())
            {
                fin.get(now);
                if(now == &#39;\r&#39; || now == &#39;\n&#39;)
                    break;
            }
            if(now == &#39;\n&#39;)     // 不是回车换行符，回退
                fin.unget();
        }
        else if(next == &#39;*&#39;)    //多行注释
        {
            while(!fin.eof())
            {
                fin.get(next);
                if(next == &#39;*&#39;)
                {
                    fin.get(next);
                    if(next == &#39;/&#39;)
                        break;
                }
            }
        }
    }
}
</code></pre>]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>预处理</tag>
        <tag>词法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言实现冒泡排序算法</title>
    <url>/AssemblyLanguage-SwapSort.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　    初学汇编语言，自己便许下了用汇编实现冒泡排序算法的“宏愿”，现在也终于实现了一部分。用高级编程语言的思想指导低级编程语言来实现算法，在过去算奢侈，现在可能是一种妥协。我会随着课程的深入来改正这个程序。在这里记录历程。<br><a id="more"></a></p>
<h3 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h3><pre><code class="lang-assembly">include vcIO.inc
; 过程功能：冒泡排序
.data; set data segment
arr dd 10,2,3,2,5,21,32,12,43,12,33,43,54,66,87,89,00,4,2,6; 待排序数组
len1 byte ? ; 数组长度
len2 byte ? ;内层循环边界
fmt byte &#39;%d &#39;,0
.code
main proc
    mov len1,lengthof arr
    mov ebx,offset arr
    mov al,0h    ;外层循环变量

    ;外层循环体
lp:
    cmp al,len1
    jnb done; 结束循环

    ; 内层循环体
    mov ah, 1h; 内层循环变量
inner:
    ;内层循环判断索引部分
    mov cl,len1
    mov len2,cl
    sub len2,al
    cmp ah,len2
    jnb last
    movsx esi,ah    ;得到待比较的两个元素索引
    mov bl,ah
    sub bl,1
    movsx edi,bl
    mov ecx, arr[(type arr)*esi]
    mov edx, arr[(type arr)*edi]
    cmp ecx,edx
    jnb follow        ;交换元素
    mov edx,arr[(type arr)*esi]
    xchg edx,arr[(type arr)*edi]
    xchg edx,arr[(type arr)*esi]
follow:
    inc ah        ;内层循环更新
    jmp inner
last:
    inc al        ;外层变量更新
    jmp lp
done:
    xor ecx,ecx
    mov al,len1
prt:
    movsx ebx,al
    cmp ecx,ebx
    jnb fina
    mov edx, arr[(type arr)*ecx]
    pushad
        invoke printf,offset fmt,edx
    popad
    inc ecx
    jmp prt
fina:
    ret        ; return to windows
main endp    ; (insert additional procedures here)
end  main    ; end of assembly
</code></pre>
<h3 id="版本2-子程序版"><a href="#版本2-子程序版" class="headerlink" title="版本2(子程序版)"></a>版本2(子程序版)</h3><p>　　知道和运用之间总是隔着一个三维宇宙😁，这次更新带比例的的相对基址变址寻址，这样就不用单纯的通过改变索引（还是高级语言编程的习惯）来访问数组元素了。</p>
<pre><code class="lang-assembly">include vcIO.inc
;过程功能
;主程序验证 ，子程序冒泡排序，通过堆栈传递参数
.data
arr dword 10, 2, 3, 2, 5, 21, 32, 12, 43, 12, 33, 43, 54, 66, 87, 89, 00, 4, 2, 6; 待排序数组
fmt byte &#39;%d &#39;,0
.code
main proc
    push lengthof arr ;数组长度压栈
    push offset arr      ;数组首地址压栈

    call bubbleSort

    add esp,8    ;堆栈平衡

    ; 打印结果
    mov ecx,lengthof arr
    mov ebx,offset arr
    xor esi,esi
again:
    mov eax,[ebx+4*esi]
    pushad
        invoke printf,offset fmt,eax
    popad
    inc esi
    loop again

bubbleSort proc
    push ebp    ;保护ebp内容
    mov ebp,esp ;取得最低地址堆栈指针
    push eax
    push ebx
    push ecx
    push edx
    push edi
    push esi
    mov ebx,[ebp + 8]    ;取出数组偏移地址
    mov ecx,[ebp + 12] ; 取出数组长度

    xor esi,esi    ;外层循环变量
outer:
    cmp esi,ecx
    jnb done    ;排序结束跳转

    push ecx
    sub ecx,esi    ;内层循环边界
    mov eax,ecx
    pop ecx

    xor edi,edi    ;内层循环变量
    inc edi        ;内层从1开始，比较arr[i]和arr[i-1]
inner:
    cmp edi,eax
    jnb next    ;内层循环结束

    push ecx    ; 交换准备

    ;待修改块
    ;带比例的基址变址寻址
    ;mov edx, [ebx + 4 * edi]
    ;dec edi
    ;mov ecx, [ebx + 4 * edi]
    ;inc edi

    ;带比例的相对基址变址寻址
    mov edx, [ebx + 4 * edi]
    mov ecx, [ebx + 4 * edi - 4]

    cmp edx, ecx
    jnb beyond
    ; 交换数据(待修改块)
    ;dec edi
    ;xchg edx, [ebx + 4 * edi]
    ;inc edi
    ;xchg edx, [ebx + 4 * edi]

    ;带比例的相对基址变址寻址
    xchg edx, [ebx + 4 * edi - 4]
    xchg edx, [ebx + 4 * edi]
beyond:
    pop ecx
    inc edi
    jmp inner
next:
    inc esi
    jmp outer
done:
    pop esi
    pop edi
    pop edx
    pop ecx
    pop ebx
    pop eax
    pop ebp
    ret
bubbleSort endp
    ret
main endp
end main
</code></pre>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
        <tag>AssemblyLanguage</tag>
      </tags>
  </entry>
  <entry>
    <title>那迷人的欧拉公式</title>
    <url>/EulerFormula.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　数学的确是人们从感性认知世界到理性度量世界的巨大的转变，既然历史已经走到了这里，那我们可以称它为是一种进步。So，我在这里观叹“上帝创造”的公式——<strong>欧拉公式</strong>（又称为欧拉恒等式）。<br><a id="more"></a></p>
<h1 id="e-pi-i-1-0"><a href="#e-pi-i-1-0" class="headerlink" title="e^{\pi i}+1=0"></a><strong><script type="math/tex">e^{\pi i}+1=0</script></strong></h1><p>这个公式将复数单位——i，圆周率——$\pi$，自然对数的底数——e，整数的单位——1以及人类最伟大的发明——0，联系在了一起，并由此产生了无限的可能。比如，我们可以解出类似于$x^{2}=-1$方程的解（$i^2=-1$)。也可以将对数函数的定义域扩展到全体实数（扩展这个词是借鉴复数将实数所在的一维数轴扩展成具有实轴和虚轴的二维复平面），例如</p>
<script type="math/tex; mode=display">ln(-5)=ln(5e^{\pi i})</script><script type="math/tex; mode=display">=ln5+ln(e^{\pi i})=ln5+\pi i</script><p>是不是打开了新世界的大门？本来在实数集上，$y=lnx$的定义域为$D_{f}={x|x\gt 0}$，而当扩展到了复数集时，ln(-5)就有意义了。再多说一点，既然复数能扩展到二维复平面，那么它还能不能扩展到更多的维度呢？答案是可以的，比如<a href="https://www.zhihu.com/question/23005815">四元组</a>。<br>下面我以证明欧拉公式为目的，从泰勒公式开始总结：</p>
<h4 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h4><p>　　我们知道当$x→0$时，会存在一些等价无穷小，例如$sin(x)$~$x,tan(x)$~$x$。而采用等价无穷小后，会方便我们对一些函数的性态做研究。一方面，我们令$P(n)$为$f(x)$在$x_{0}$处的等价的多项式，它与$f(x)$之间相差一个无穷小。</p>
<script type="math/tex; mode=display">P(x)=a_{0}+a_{1}(x-x_{0})+a_{2}(x-x_{0})^{2}+</script><script type="math/tex; mode=display">...+a_{n}(x-x_{0})^{n}　(*)</script><p>可以想象一下我们拟合曲线时的操作，尽量让拟合的曲线的走势与被拟合的函数一致，说到曲线的趋势，我们必会提到导数。所以，设</p>
<script type="math/tex; mode=display">P(x_0)=f(x_0), P'(x_0)=f'(x_0)</script><script type="math/tex; mode=display">P''(x_0)=f''(x_0),..., P^{(n)}(x_0)=f^{(n)}(x_0)</script><p>即是</p>
<script type="math/tex; mode=display">a_0=f(x_0), a_1=f'(x_0)</script><script type="math/tex; mode=display">2!a_2=f''(x_0),...,n!a_n=f^{(n)}(x_0)</script><p>所以多项式对应的系数已求出，将之代入(*)式，得到$f(x)$的在$x=x_0$处的泰勒展开式：</p>
<script type="math/tex; mode=display">f(x)=f(x_0)+f'(x_0)(x-x_0)+</script><script type="math/tex; mode=display">\frac{f''(x_0)}{2!}(x-x_0)+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)</script><p>因为本文目的是证明欧拉公式，所以这里就不讨论误差。<br>下面是用Octave画出y=sinx在x=0处展开3，5阶麦克劳林公式并与y=sinx对比的图像，</p>
<p><center><img src="image/curve.png" width="450" height="300"/></center><br>可以看出泰勒展开的阶数越高，曲线拟合效果越好。</p>
<h4 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h4><p>由上面定义，我们可以得到三个关键函数在$x=0$处的省略余项的麦克劳林公式:</p>
<script type="math/tex; mode=display">e^{x}=1+x+\frac{x^{2}}{2!}+\frac{x^{3}}{3!}+...+\frac{x^{n}}{n!}</script><script type="math/tex; mode=display">sinx=x-\frac{x^{3}}{3!}+...+(-1)^{(n-1)}\frac{x^{2n-1}}{(2n-1)!}</script><script type="math/tex; mode=display">cosx=1-\frac{x^2}{2!}+...+(-1)^n\frac{x^{2n}}{(2n)!}</script><p>正式开始证明欧拉公式：<br>在$e^{x}$的展开式中把$x$换成$±ix$，</p>
<script type="math/tex; mode=display">(±i)^2=-1,(±i)^{3}=∓i,(±i)^{4}=1,...</script><script type="math/tex; mode=display">e^{±ix}=1±\frac{ix}{1!}-\frac{x^2}{2!}∓\frac{ix^3}{3!}+\frac{x^4}{4!}</script><script type="math/tex; mode=display">=(1-\frac{x^2}{2!}+...)±i(x-\frac{x^3}{3!}...)</script><p>所以</p>
<script type="math/tex; mode=display">e^{±ix}=cosx±isinx</script><p>分开写得到：</p>
<script type="math/tex; mode=display">e^{ix}=cosx+isinx　　(1)</script><script type="math/tex; mode=display">e^{-ix}=cosx-isinx　 (2)</script><p>(1)-(2)得到:</p>
<script type="math/tex; mode=display">sinx=\frac{e^{ix}-e^{-ix}}{2i}　(3)</script><p>(1)+(2)得到：    </p>
<script type="math/tex; mode=display">cosx=\frac{e^{ix}+e^{-ix}}{2}　 (4)</script><p>上两式也称为欧拉公式。<br>对于（1）式，取$x=\pi$，得到欧拉公式：</p>
<h1 id="e-pi-i-1-0-1"><a href="#e-pi-i-1-0-1" class="headerlink" title="e^{\pi i}+1=0"></a><strong><script type="math/tex">e^{\pi i}+1=0</script></strong></h1>]]></content>
      <categories>
        <category>迷人数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>泰勒公式</tag>
        <tag>欧拉公式</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈动态规划算法</title>
    <url>/SummaryofDynamicPaogramming.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　关于动态规划(Dynamic Programming)算法，我在算法设计课上理解得并不是多么深刻。所以自己还是下来查找资料，多方对比学习，以期有所获。在这里谈一下心路历程与总结。<br><a id="more"></a><br>　　动态规划是运筹学中求解决策过程中的<strong>最优化</strong>数学方法。在计算机科学中，它也是一种程序算法设计技术。这就是基础科学在计算机科学中的一种应用。在这里我们只关注它作为算法设计技术的特性。</p>
<h3 id="LV1-初识"><a href="#LV1-初识" class="headerlink" title="LV1-初识"></a>LV1-初识</h3><p>　　一开始，课本上就扔出几个术语，最优子结构、重叠子问题，对于初学者来说的确是高深莫测，只有真的勇士才敢逆流而上，去一步一步剖析这些特性，最终能够领略它的独特风光。这里我们就逐个击破这些术语，揭开DP的面纱…</p>
<h4 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h4><p>下面我们直接看经典的<a href="http://acm.wust.edu.cn/problem.php?cid=1316&amp;pid=5">数塔问题</a>:</p>
<blockquote>
<p>从数塔顶部开始往下走，每次往下走只能选一个节点，一直到最底层，使走过的所有节点的数字之和最大，求这个最大和。假设顶部为第一层，以此类推。<br>数组$number[i][j]$表示数塔第i层左起第j个元素。    </p>
</blockquote>
<p><img src="image/numberTower.png" width="400" height="300"/><br>我们假定:<br>$dp[i][j]$表示从位置$(i,j)$到达数塔的最底层所经过路径的最大值。<br>我们要得到该最大值，就必须得到分别从位置$(i+1,j+1)$和$(i,j+1)$这两个节点出发，到达最底层时，所经过的数字的最大值。<br>此时，它们的关系为:</p>
<pre><code>dp[i][j]=max(dp[i][j+1],dp[i+1][j+1])+number[i][j]
</code></pre><p>例如对于图中节点<strong>数字9</strong></p>
<pre><code>dp[1][1]=max(dp[2][1],dp[2][2])+9
</code></pre><p>这样我们得到的一般的等式就称为状态转移方程。</p>
<ul>
<li>其中$dp[i][j]$表示一个状态，它的值总是来自于从子问题：$dp[i+1][j]$与$dp[i+1][j+1]$中选取一个较大值与当前节点数字相加，<br>之后对于节点$dp[i+1][j]$，它的值来自$dp[i+2][j]$与dp$[i+2][j+1]$中较大值与当前节点$number[i][j]$的和；$dp[i+1][j+1]$亦然。<br><strong>这就是最优子结构性质</strong>，每一个问题都划分为两个子问题，然后在两个子问题中选择最优的(也就是所经过的数字之和最大)，得到母问题的最优解(当然是最优的)。</li>
<li>最终到了数塔最底层，此时已没有子问题，所以<br>假设数塔有n层，第n层有m个元素，<br>则$dp[n][j]=number[n][j]（1\leq j \leq m）$，这就称为递推边界。<br>从递推边界开始，根据状态转移方程，最终得到最优解$dp[1][1]$。<br>下面是C++代码:<pre><code class="lang-C++">#include&lt;iostream&gt;
#include&lt;array&gt;
#define ROW 4
#define COL 4
using namespace std;
int main()
{
  array&lt;array&lt;int, ROW+1&gt;, COL+1&gt; tower;
  array&lt;array&lt;int, ROW+1&gt;, COL+1&gt; dp;
  for(int i = 0; i &lt; ROW; i++)
      tower[i].fill(0);
  for(int i = 1; i &lt;= ROW; i++)
      for(int j = 1; j &lt;= i; j++)
          cin &gt;&gt; tower[i][j];
  for(int i = 1; i &lt;= ROW; i++)         // 递推边界
      dp[ROW][i] = tower[ROW][i];
  for(int i = ROW - 1; i &gt;= 1; i--)
  {
      for(int j = 1; j &lt;= i; j++)
      {
          dp[i][j] = max(dp[i + 1][j], dp[i +  1][j + 1]) + tower[i][j];  // 状态转移方程递推
      }
  }
  cout &lt;&lt; dp[1][1] &lt;&lt; endl;
  return 0;
}
</code></pre>
<h4 id="总结分析过程"><a href="#总结分析过程" class="headerlink" title="总结分析过程"></a>总结分析过程</h4></li>
</ul>
<ol>
<li>我们一开始提出用$dp[i][j]$表示从u数塔位置$(i,j)$到最底层，这就是它的意义所在，我们需要找到一个递推关系，也就是动态转移方程。所以我们在使用动态规划算法设计程序时，首先要明确$dp[i][j]$这个状态的意义。当然，这肯定是一个艰难的过程。</li>
<li>在我们明白这个$dp[i][j]$所表示的意义时，就要通过正推或者逆推得到状态转移方程。步骤1、2我这里分开是便于叙述，在思考时是万万不能分开的。要根据问题，怎样设计出合理的$dp[i][j]$表示的状态，得到状态转移方程。</li>
<li>最后，在前两步完成的情况下，思考出递推边界情况，可以通过正推状态转移方程也可以逆推状态转移方程得出边界。  </li>
</ol>
<h3 id="上面的数塔问题包含最优子结构性质，下面再解析重叠子问题。"><a href="#上面的数塔问题包含最优子结构性质，下面再解析重叠子问题。" class="headerlink" title="上面的数塔问题包含最优子结构性质，下面再解析重叠子问题。"></a>上面的数塔问题包含最优子结构性质，下面再解析重叠子问题。</h3><p>经典问题</p>
<blockquote>
<p>求解斐波那契数列的第n项。  </p>
</blockquote>
<p>我们很容易写出递归式:</p>
<pre><code class="lang-c++">int f(int n)
{
    if(n &lt; 0)
        return -1;
    if(n == 1 || n == 2)
        return 1;
    return f(n-1) + f(n-2);
}
</code></pre>
<p>对于该递归我们可以得到一棵二叉树:<br><img src="image/recursion.png" width="500" height="300"/><br>图中，我们在对$f(5)$递归求解时调用了两次$f(3)$，我们明明可以只用求解一次然后将答案记录下来，再用时直接访问答案就可以了。这就是重叠子问题。<br>这里就要提一下备忘录方法了，这其实是动态规划的变形，并且它将计算过的子问题都会保存到数组中，下一次遇见相同的子问题直接调用即可。</p>
<ul>
<li>我们用$dp[n]$表示第$n$项斐波那契数列，不难得到其动态转移方程为<pre><code class="lang-c++">dp[n]=dp[n-1]+dp[n-2]
</code></pre>
</li>
<li>其递归边界dp[1]=1,dp[2]=1，所以我们可以写出使用自顶向下的备忘录方法求解斐波那契数列<pre><code class="lang-c++">array &lt; int, 100&gt; dp = {0};
int f(int n)
{
  if(n &lt; 0)
      return -1;
  if(dp[n])
      return dp[n];
  if(n == 1 || n == 2)
      return dp[1] = dp[2] = 1;
  return dp[n] = f(n - 1) + f(n - 2);
}
</code></pre>
当然我们也可以写成动态规划形式，假设求第$n$项斐波那契数列:<pre><code class="lang-c++">array &lt; int, 47&gt; dp = {0};        // 整形范围内，第47项斐波那契数列溢出
dp[1]=dp[2]=1;
for(int i=3;i&lt;=n;i++)
{
  dp[i]=dp[i-1]+dp[i-2];
}
</code></pre>
可以观察到在求解$dp[n]$的过程中，只有$dp[n-1]$和$dp[n-2]$有效，比如$dp[3]=dp[2]+dp[1]，dp[4]=dp[3]+dp[2]$，而$dp[1]$已经没有用处了。所以我们完全可以不用数组，只用两个变量$a,b$：<pre><code class="lang-c++">int f(int n)
{
  if(n &lt; 0)
      return -1;
  if(n == 1 || n == 2)
      return 1;
  int a = 1, b = 1, ans = 0;
  for(int i = 3; i &lt;= n; i++)
  {
      ans = a + b;
      a = b;
      b = ans;
  }
  return ans;
}
</code></pre>
空间复杂度由$O(n)$下降到$O(1)$，不得不说这是一个巨大的飞跃。所以根据动态规划的递推式，我们可以通过观察来一定程度优化空间复杂度，这都是后话了。<h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3>　　关于动态规划算法，我这里展示的只是冰山一角。每个人都会有其独特的理解，有人认为它是在填矩阵，有人认为它是一种拓扑排序（想来的确如此），如《哈姆雷特》一般。<br>对于我们普通人来说，不可能一次就完完全全的领悟。需要一段时间的沉淀，需要不断地总结、练习，以更上一层楼。<br>推荐阅读：<br><a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a></li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>7-36 复数四则运算 （15 分）</title>
    <url>/complexCalc.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　亲爱的您既然来看这道题的题解，那么您很有可能落入了一个题目的陷阱，在这里，我建议亲再<strong>仔仔细细的</strong>回去读一下题目呢，也好给自己留一个深刻的教训。<br><a id="more"></a><br>    这是<a href="https://pintia.cn/problem-sets/14/problems/816">题链接</a>，</p>
<ul>
<li>注意到题面<pre><code>如果结果的实部或者虚部为0，则不输出。如果结果为0，则输出0.0。
</code></pre>注意一个词，<strong>结果</strong>！也就是打印时，等号左边和右边不是一个规则：</li>
<li><strong>对于结果，实部或者虚部为0，则不输出；然而，对于算式也就是等式右边，实部或者虚部为0，则 还 是 需 要 进 行 输 出</strong></li>
<li>哈哈哈😆😆555😭😭~<h2 id="深刻的反思"><a href="#深刻的反思" class="headerlink" title="深刻的反思"></a><strong>深刻的反思</strong></h2>  由于我过早的考虑代码复用，就把等式左右两边打印复数用了同一套规则，结果一时错，一时爽；一直错，一直爽…被折磨了两小时。<br>一开始打印部分我是这样写的:<pre><code>void printExp(double a, double b, bool flag)
{
  if(abs(a) &lt; 0.05 &amp;&amp; abs(b) &lt; 0.05)
  {
      printf(&quot;0.0&quot;);
  }
  else
  {
      if(flag)
          printf(&quot;(&quot;);
      // 实部
      if(abs(a) &gt;= 0.05)
      {
          printf(&quot;%.1lf&quot;, a);
      }
      // 虚部
      if(abs(b) &gt;= 0.05)
      {
          // 虚部的 + 符号
          if(b &gt; 0 &amp;&amp; abs(a) &gt;= 0.05)
              printf(&quot;+&quot;);
          printf(&quot;%.1lfi&quot;, b);
      }
      if(flag)
          printf(&quot;)&quot;);
  }
}
void printExpTotal(double a1, double b1, double a2, double b2, char x)
{
  printExp(a1, b1, 1);
  printf(&quot; %c &quot;, x);
  printExp(a2, b2, 1);
  printf(&quot; = &quot;);
}
</code></pre>后来我是这样写的:<pre><code>void printExp(double a, double b)
{
  if(abs(a) &lt; 0.05 &amp;&amp; abs(b) &lt; 0.05)
  {
      printf(&quot;0.0&quot;);
  }
  else
  {
      // 实部
      if(abs(a) &gt;= 0.05)
      {
          printf(&quot;%.1lf&quot;, a);
      }
      // 虚部
      if(abs(b) &gt;= 0.05)
      {
          // 虚部的 + 符号
          if(b &gt; 0 &amp;&amp; abs(a) &gt;= 0.05)
              printf(&quot;+&quot;);
          printf(&quot;%.1lfi&quot;, b);
      }
  }
}
void printExpTotal(double a1, double b1, double a2, double b2, char x)
{
  printf(&quot;(%.1lf&quot;, a1);
  if(b1 &gt;= 0)
      printf(&quot;+&quot;);
  printf(&quot;%.1lfi)&quot;, b1);
  printf(&quot; %c &quot;, x);
  printf(&quot;(%.1lf&quot;, a2);
  if(b2 &gt;= 0)
      printf(&quot;+&quot;);
  printf(&quot;%.1lfi)&quot;, b2);
  printf(&quot; = &quot;);
}
</code></pre>果断捧回AC<br>完整代码见我的<a href="https://github.com/lightingmoon/BlogResourceCode/blob/master/复数四则运算/complexCalc.cpp">Github</a><br><strong>过早优化是万恶之源，不<em>看清、想清题目要求</em>就想着优化则是万恶源之源</strong>！</li>
</ul>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title>7-23 币值转换 （20 分）</title>
    <url>/num2Chinese.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　这是一道比较麻烦的模拟题，思路和方式决定着代码量😏。<a href="https://pintia.cn/problem-sets/14/problems/803">原题链接</a>，可以先去做一下😀。<br><a id="more"></a><br>　　经历了一些小挫折以后还是AC了，题面就不搬了，开始分析:</p>
<ol>
<li>可以用一个数组保存相应位的单位，这样就不用分心考虑单位了，而只考虑各个位数字之间的关系。<br> <strong>为了相应的下标与其单位保持一致，整体后移一位。</strong><pre><code class="lang-C++">array&lt;char, 10&gt; base = {0, &#39;S&#39;, &#39;B&#39;, &#39;Q&#39;, &#39;W&#39;, &#39;S&#39;, &#39;B&#39;, &#39;Q&#39;, &#39;Y&#39;};
</code></pre>
</li>
<li>接下来讨论数字之间的关系。</li>
</ol>
<ul>
<li>可以将数字拆开放进一个数组，这样就完成了单位的映射。<pre><code class="lang-C++">int total=0;
while(n)
{
  s[total++] = n % 10;
  n /= 10;
}
</code></pre>
</li>
<li>最高位一定不是0，用pre记录前一位数字。<br>1). 如果当前位为0，且pre也为0，结束本次循环；<strong>特别的，当数字的万位也就是当前索引是4时，在前面的条件下，要输出一个W。</strong><br>2). 如果当前位不为0，但pre为0，这就是中间的0了，只用输出一次0，然后再输出本位数字和单位，例如100010。<br>3). 如果末尾全是0，则不用进行输出，在之前非0的那一位已经输出了。<br>下面是C++代码:    </li>
</ul>
<pre><code class="lang-C++">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;

int main()
{
    array&lt;int, 9&gt; s = {-1};
    array&lt;char, 10&gt; num;
    array&lt;char, 10&gt; base = {0, &#39;S&#39;, &#39;B&#39;, &#39;Q&#39;, &#39;W&#39;, &#39;S&#39;, &#39;B&#39;, &#39;Q&#39;, &#39;Y&#39;};
    int n, total = 0;
    for(int i = 0; i &lt; 10; i++)        // 数字与小写字母的映射
        num[i] = &#39;a&#39;+ i;
    cin &gt;&gt; n;
    if(n == 0)        // 单独处理0
        cout &lt;&lt; num[0];
    else
    {
        while(n)
        {
            s[total++] = n % 10;    // 将数字拆出来
            n /= 10;
        }
        int pre = -1;
        for(int i = total - 1; i &gt;= 0 ; i--)    // 从高到低位
        {
            if(s[i])
            {
                if(pre == 0)
                    cout &lt;&lt; num[0];        // 中间的0，只输出一次
                cout &lt;&lt; num[s[i]] &lt;&lt; base[i];    // 输出数字与单位
            }
            else
            {
                if(i == 4)
                    cout &lt;&lt; base[4];    // 中间的0里面有万位，另外输出
                if(pre == 0)    // 中间0，跳过处理
                    continue;
            }
            pre = s[i];
        }
    }
    cout &lt;&lt; &#39;\n&#39;;
    return 0;
}
</code></pre>
<p>反思:<br><strong>在做比较麻烦的模拟题时，千万不要顺着思路去模拟，要时常跳出思维，要自己制定规则，<br>怎么方便怎么来。有时候顺着写，枚举特例，不仅大大增加了代码量，而且枚举时可能会漏掉某些条件，最终功败垂成。</strong></p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习之线性回归</title>
    <url>/MachineLearning-LinerRegression.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　自己早已对机器学习观望已久，现在不入门，更待何时？在找到<a href="https://www.coursera.org/learn/machine-learning">Coursera</a>时，发现教学方法很对胃口，于是开始ML之旅…现在在这里总结一下机器学习之线性回归。<br><a id="more"></a><br>　　机器学习有很多种方式，比如监督学习，半监督学习，无监督学习等。它们区别于训练集的种类，比如监督学习的训练集其每一个训练样本都有正确的答案，而无监督学习则没有，只能通过算法自动分类。而半监督学习，顾名思义，一部分是监督学习，一部分是无监督学习。  </p>
<h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>　　监督学习又分为聚类和回归。其中聚类是预测连续值，回归是预测离散值。例如垃圾邮件识别，网页类别划分等是聚类。预测房价、股票涨跌等是回归。<br>下面总结一下线性回归。</p>
<h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>线性回归模型</p>
<blockquote>
<p>截取自Coursera课程课件    </p>
</blockquote>
<p><center><img src="image/LinerRgressionModel.png" width="450" height="300"/></center><br>假设有房价数据集如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">房子面积/$m_{2}$(x)</th>
<th style="text-align:center">价格/w(y)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">80</td>
<td style="text-align:center">40</td>
</tr>
<tr>
<td style="text-align:center">90</td>
<td style="text-align:center">60</td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<p><strong>数据集1</strong><br>以下为一些字母的含义：     </p>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字母</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$m$</td>
<td style="text-align:center">表示训练样本数量</td>
</tr>
<tr>
<td style="text-align:center">$x$</td>
<td style="text-align:center">表示输入特征(特征量)</td>
</tr>
<tr>
<td style="text-align:center">$y$</td>
<td style="text-align:center">表示输出变量(目标量)</td>
</tr>
<tr>
<td style="text-align:center">$(x,y)$</td>
<td style="text-align:center">表示一个训练样本</td>
</tr>
<tr>
<td style="text-align:center">$(x^{(i)},y^{(i)})$</td>
<td style="text-align:center">表示第i个训练样本</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>对应于线性回归的<strong>假设函数(hypothesis function)</strong>为 </p>
<script type="math/tex; mode=display">h_{\theta}(x)=\theta_{0}+\theta_{1}x</script><p>其中$\theta$为参数<br>对应的<strong>代价函数(cost function)</strong>(其图像为一个凹函数)为</p>
<script type="math/tex; mode=display">J(\theta_{0},\theta_{1})=\frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2</script><p>这个方程有什么<strong>意义</strong>呢？<br>下面是一个散点图:</p>
<p><center><img src="image/linerRegression.png" width="450" height="300"/></center><br>由图片e表示假设函数结果与训练样本之间的误差。</p>
<script type="math/tex; mode=display">e_{0}=h_{\theta}(1)-y_{0}</script><script type="math/tex; mode=display">e_{1}=h_{\theta}(2)-y_{1}</script><script type="math/tex; mode=display">e_{2}=h_{\theta}(3)-y_{2}</script><script type="math/tex; mode=display">...</script><p>所有误差的和即为</p>
<script type="math/tex; mode=display">\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})</script><p>要想得到拟合最好的效果，我们必须要让误差和最小。但是通常我们都用平均每个训练样本的误差的一半来表示。也即代价函数：</p>
<script type="math/tex; mode=display">J(\theta_{0},\theta_{1})=\frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})^2</script><p>此时得到的参数$\theta<em>{0},\theta</em>{1}$为最合适的参数。 </p>
<hr>
<h3 id="梯度下降算法-Gradient-Descent-Algorithm"><a href="#梯度下降算法-Gradient-Descent-Algorithm" class="headerlink" title="梯度下降算法(Gradient Descent Algorithm)"></a>梯度下降算法(Gradient Descent Algorithm)</h3><script type="math/tex; mode=display">\theta_{j}=\theta_{j}-\alpha\frac{\partial{J(\theta_{0},\theta_{1})}}{\partial{j}}</script><p>其中$\theta$表示参数，$\alpha(\geq0)$表示学习效率，后面表示$\theta<em>{j}$的偏导。<br>为了叙述方便，下面令$\theta</em>{0}=0$，此时$J({\theta<em>{1}})$只有一个参数$\theta</em>{1}$，令$J(\theta)$最小值对应于$\theta_{min}$   </p>
<ul>
<li>假如$\theta<em>{1}&gt;\theta</em>{min}$，则该点切线斜率大于等于0，即$\frac{dJ(\theta<em>{1})}{d\theta</em>{1}}\geq 0$(因为只有一个参数，所以退化为求微分)，所以<script type="math/tex">\theta_{1}=\theta_{1}-\alpha\frac{dJ(\theta_{1})}{d\theta_{1}}</script>，$\theta<em>{1}$减去一个正数，$\theta</em>{1}$减小，则$\theta<em>{1}$更靠近$\theta</em>{min}$</li>
<li>$\theta<em>{1}&lt;\theta</em>{min}$分析方法类似    </li>
</ul>
<h3 id="梯度下降算法在线性回归中的应用"><a href="#梯度下降算法在线性回归中的应用" class="headerlink" title="梯度下降算法在线性回归中的应用"></a>梯度下降算法在线性回归中的应用</h3><p>　　将之前的代价函数带入梯度下降算法里，得到(其实就是复合函数求导，可以手动算一下):</p>
<script type="math/tex; mode=display">\theta_{0}=\theta_{0}-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})</script><script type="math/tex; mode=display">\theta_{1}=\theta_{1}-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})*x_{1}</script><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><p>有数据集如下:    </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$x_{0}$</th>
<th style="text-align:center">房子面积/$m<em>{2}(x</em>{1})$</th>
<th style="text-align:center">卧室数量$(x_{2})$</th>
<th style="text-align:center">层数$(x_{3})$</th>
<th style="text-align:center">房子寿命$(x_{4})$</th>
<th style="text-align:center">价格/w(y)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">80</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">50</td>
<td style="text-align:center">50</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">90</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">60</td>
<td style="text-align:center">60</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">100</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">70</td>
<td style="text-align:center">60</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<p><strong>数据集2</strong><br><strong>PS:为了$\theta<em>{i}$与$x</em>{j}$下标一致，所以多加一列，其所有值都为1</strong></p>
<p>补充字母含义:    </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字母</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">n</td>
<td style="text-align:center">特征数量</td>
</tr>
<tr>
<td style="text-align:center">$x^{(i)}$</td>
<td style="text-align:center">第i个训练样本</td>
</tr>
<tr>
<td style="text-align:center">$x^{(i)}_{j}$</td>
<td style="text-align:center">$i^{th}$训练样本$j^{th}$特征值</td>
</tr>
</tbody>
</table>
</div>
<p>此时,假设函数为:</p>
<script type="math/tex; mode=display">h_{\theta}(x)=\theta_{0}x_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}+...+\theta_{n}x_{n}</script><p>代价函数:</p>
<script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^{m}(\theta^{T}x^{(i)}-y^{(i)})^2</script><p>也等价于</p>
<script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^{m}((\sum_{j=0}^{n}\theta_{j}x_{j}^{(i)})-y^{(i)})^2</script><p>则梯度下降算法对应的偏导为:</p>
<script type="math/tex; mode=display">\theta_{j}=\theta_{j}-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})*x_{j}^{(i)}</script><h3 id="加快梯度下降算法收敛方法"><a href="#加快梯度下降算法收敛方法" class="headerlink" title="加快梯度下降算法收敛方法"></a>加快梯度下降算法收敛方法</h3><ol>
<li>特征缩放(feature scaling)<br>　保证每个特征量范围都在$-1\geq x_{i}\geq 1$，每个特征值除以该特征范围。</li>
<li>均值归一化(mean normalization)<br>　保证特征变量在$-0.5\geq x_{i} \geq 0.5$，令<script type="math/tex; mode=display">x_{i}=\frac{x_{i}-\mu_{i}}{s_{i}}</script>其中，$\mu<em>{i}$表示$i^{th}$特征的均值，$s</em>{i}$表示表示$i^{th}$特征的范围或标准差。</li>
<li>调整学习效率$\alpha$<br>　$\alpha$必须足够小，且$J(\theta)$必须在每一次迭代后减小，可以以每次为原来的3倍来调整$\alpha$。<ul>
<li>当$\alpha$太小，算法收敛过慢。</li>
<li>当$\alpha$太大，$J(\theta)$可能在迭代若干次后开始增加，最终算法不能收敛。   </li>
</ul>
</li>
</ol>
<h2 id="多项式线性回归"><a href="#多项式线性回归" class="headerlink" title="多项式线性回归"></a>多项式线性回归</h2><p>　当假设函数不再是线性时，可以通过平方，立方，开平方来进行多项式拟合。<br>e.g<br>$h<em>{\theta}(x)=\theta</em>{0}+\theta<em>{1}x</em>{1}$<br>对于<strong>数据集1</strong>，可以令</p>
<ol>
<li>$h<em>{\theta}(x)=\theta</em>{0}+\theta<em>{1}x</em>{1}^{2}$<br> 此函数为二次函数，根据实际情况，房价不可能随面积增大而减小。</li>
<li>$h<em>{\theta}(x)=\theta</em>{0}+\theta<em>{1}x+\theta</em>{1}x<em>{1}^{2}+\theta</em>{2}x<em>{1}^{3}$<br> 此函数中，令$x</em>{2}=x<em>{1}^{2}，x</em>{3}=x^{3}_{1}$，此时，三个特征范围相差过大，对于特征值归一化有不利影响。</li>
<li>$h<em>{\theta}(x)=\theta</em>{0}+\theta<em>{1}x</em>{1}+\theta<em>{2}\surd{x</em>{1}}$<br> 此时较符合模型。运用此方法 ，特征缩放很重要，而且特征之间关联程度要小。</li>
</ol>
<h2 id="正规方程-Normal-Equation"><a href="#正规方程-Normal-Equation" class="headerlink" title="正规方程(Normal Equation)"></a>正规方程(Normal Equation)</h2><p>　对于训练样本数为m，特征数为n，<br>令矩阵  </p>
<script type="math/tex; mode=display">X=\left[   \begin{matrix} x_0^{i} & x_1^{i} & x_2^{i} & x_3^{i} &...\end{matrix}   \right]^{T}</script><p>其中<script type="math/tex">(1\leq i \leq m)</script>，X为m*(n+1)阶矩阵。</p>
<script type="math/tex; mode=display">y=\left[ \begin{matrix} y^{(1)} \\
            y^{(2)} \\
            ... \\
            y^{(m)} \end{matrix} \right]</script><p>有正规方程，在数学上可证明其正确性:</p>
<script type="math/tex; mode=display">\theta=(X^{T}X)^{-1}X^{T}y</script><p>最终$\theta$为1*(n+1)阶矩阵    </p>
<h3 id="梯度下降算法与正规方程比较"><a href="#梯度下降算法与正规方程比较" class="headerlink" title="梯度下降算法与正规方程比较"></a>梯度下降算法与正规方程比较</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">梯度下降算法</th>
<th style="text-align:center">正规方程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">需要选择$\alpha$</td>
<td style="text-align:center">不需要选择$\alpha$</td>
</tr>
<tr>
<td style="text-align:center">需要多次迭代</td>
<td style="text-align:center">不需要迭代</td>
</tr>
<tr>
<td style="text-align:center">时间复杂度为$O(kn^{2}$)</td>
<td style="text-align:center">$O(n^{3}$)，主要在矩阵求逆</td>
</tr>
<tr>
<td style="text-align:center">当n很大时，能运行得不错</td>
<td style="text-align:center">当n很大时，因为矩阵求逆而速度很慢</td>
</tr>
</tbody>
</table>
</div>
<p><strong>注: 当n大于10000时，考虑用梯度下降算法</strong></p>
<h3 id="正规方程不可逆"><a href="#正规方程不可逆" class="headerlink" title="正规方程不可逆"></a>正规方程不可逆</h3><ol>
<li>存在多余的特征，即存在关联程度很大的特征，此时可以分析特征，删去关联程度大的特征中一个。</li>
<li>特征值太多，例如$m&lt;n$。此时可以删去存在关联的特征，或进行正则化。</li>
</ol>
<p>夜已深，就总结到这里，接下来准备做一个小项目。晚安~</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>监督学习</tag>
        <tag>线性回归</tag>
        <tag>梯度下降算法</tag>
        <tag>正规方程</tag>
      </tags>
  </entry>
  <entry>
    <title>二分算法总结</title>
    <url>/BinaryPractice.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　关于二分算法想必大家也是耳熟能详,但是在实施算法时，往往在细节方面由于没有考虑周全而抓耳挠腮，百思不得其解。这很正常。因为当年在学术界，第一个正确的二分算法写出来就花了<strong>20</strong>年；又不正常。现在，对于二分算法无论是理论研究还是实际运用都已经很纯熟了，我们既然可以站在巨人的肩膀上，那又何乐而不为呢？<br><a id="more"></a><br>　　这里总结一下一些常用的二分算法的写法。</p>
<h3 id="一、二分查找"><a href="#一、二分查找" class="headerlink" title="一、二分查找"></a>一、二分查找</h3><p>　　查找序列为<strong>严格递增序列</strong>，元素所在区间为[0,n-1]。当元素存在重复时，它不保证返回序列中第一个该元素的索引，故待查找序列不应存在重复元素。</p>
<pre><code>int binarySearch(int l, int r, int x)
{
    int mid;
    while(l &lt;= r)            /* 若此时l==r，还要进行一次查找*/
    {                        /* 当l&gt;r时，查找失败，退出循环*/
        mid = (l + r) / 2;    /* 备注1 */
        if(s[mid] == x)        /* 返回元素所在序列的索引*/
            return mid;
        if(s[mid] &gt; x)
            r = mid - 1;    /* 此时目标元素x存在区间为[l,mid - 1]*/
        else
            l = mid + 1;    /* 此时目标元素x存在区间为[mid + 1,r]*/
    }
    return -1;                /* 没有找到，返回-1*/
}
</code></pre><p><strong>备注1：此处可能存在 l + r 溢出int范围，所以可以用 l + (r-l)/2避免溢出</strong></p>
<h3 id="二、解析STL中lower-bound和upper-bound"><a href="#二、解析STL中lower-bound和upper-bound" class="headerlink" title="二、解析STL中lower_bound和upper_bound"></a>二、解析<a href="https://baike.baidu.com/item/STL/70103">STL</a>中lower_bound和upper_bound</h3><h5 id="lower-bound-求序列中第一个大于等于目标元素x的索引"><a href="#lower-bound-求序列中第一个大于等于目标元素x的索引" class="headerlink" title="lower_bound(求序列中第一个大于等于目标元素x的索引)"></a>lower_bound(求序列中第一个大于等于目标元素x的索引)</h5><p>　　查找序列为非递减序列，初始区间为[1,n]——(因为x可能大于序列中所有的元素，此时满足条件的元素就是其本身，此时返回值为n)，</p>
<pre><code>int lower_bound(int l, int r, int x)
{
    int mid;
    while(l &lt; r)            /* 当l==r时，该位置唯一，循环结束*/
    {
        mid = l + (r - l) / 2;
        if(s[mid] &gt;= x)        /* 第一个大于等于x的索引在[l, mid]里 */
            r = mid;
        else
            l = mid + 1;    /* 第一个大于等于x的索引在[mid+1, r]里 */
    }
    return l;
}
</code></pre><h5 id="upper-bound-求序列中第一个大于目标元素x的索引"><a href="#upper-bound-求序列中第一个大于目标元素x的索引" class="headerlink" title="upper_bound(求序列中第一个大于目标元素x的索引)"></a>upper_bound(求序列中第一个大于目标元素x的索引)</h5><p>　　查找序列为非递减序列，代码与与上面类似。</p>
<pre><code>int lower_bound(int l, int r, int x)
{
    int mid;
    while(l &lt; r)            /* 当l==r时，该位置唯一，即是目标位置，循环结束*/
    {
        mid = l + (r - l) / 2;
        if(s[mid] &gt; x)        /* 第一个大于x的索引在[l, mid]里 */
            r = mid;
        else
            l = mid + 1;    /* 第一个大于x的索引在[mid+1, r]里 */
    }
    return l;
}
</code></pre><h3 id="三、二分思想运用"><a href="#三、二分思想运用" class="headerlink" title="三、二分思想运用"></a>三、二分思想运用</h3><p>看一道经典题:</p>
<blockquote>
<p>给出N个线段长度，试将它们头尾相接组合成一个凸多边形，使凸多边形的外接圆（多边形每个顶点都在圆上）的半径最大，求该最大半径。其中N&lt;=10^5，线段长度均不超过100，要求算法中不涉及坐标的计算。    </p>
</blockquote>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h4><h5 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h5><p>首先，因为圆心不确定，想涉及坐标计算也无能为力啊😂。<br>其次，考验数学时候来啦。我们可以确定当圆是凸多边形外接圆时，该多边形内角和为$π*(n-2)$，对于每一条弦（题中线段），与两条半径组成等腰三角形，解该等腰三角形其底角为  </p>
<script type="math/tex; mode=display">α_{i}=arccos(\frac{s_{i}/2}{r})</script><p>则凸多边形内角和为$\sum<em>{i=0}^{n-1}α</em>{i}$。此时则可以二分$r$，当内角和小于误差限时，即得到最大半径。</p>
<h5 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h5><p>换一个角度，一条线段(弦)对应的圆心角为  </p>
<script type="math/tex; mode=display">α_{i}=arcsin(\frac{s_{i}/2}{r})</script><p>而当r确定，所有的弦对应的圆心角和$\sum<em>{i=0}^{n-1}α</em>{i}=2π$，此时可以二分$r$，当内角和小于误差限时，即得到最大半径。<br>思路1和2，C++代码链接：<a href="https://github.com/lightingmoon/BlogResourceCode/blob/master/二分算法总结/findMaxRadius.cpp">二分思想题解</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>二分应用拓展</tag>
      </tags>
  </entry>
  <entry>
    <title>6-11 求自定类型元素序列的中位数</title>
    <url>/FindMiddleNumber.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　一道题把排序算法复习了个遍😂，最终复习到了堆排序。快到碗里来👇。<br><a id="more"></a></p>
<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><a href="https://pintia.cn/problem-sets/14/problems/743">原题链接</a>(要不先去做一下？😏)，题面如下，</p>
<blockquote>
<p>本题要求实现一个函数，求N个集合元素A[]的中位数，即序列中第⌊N/2+1⌋大的元素。其中集合元素的类型为自定义的ElementType。<br>函数接口定义：<br>ElementType Median( ElementType A[], int N );<br>其中给定集合元素存放在数组A[]中，正整数N是数组元素个数。该函数须返回N个A[]元素的中位数，其值也必须是ElementType类型。<br>裁判测试程序样例：</p>
<pre><code>#include &lt;stdio.h&gt;
#define MAXN 10
typedef float ElementType;
ElementType Median( ElementType A[], int N );
int main ()
{
    ElementType A[MAXN];
    int N, i;
    scanf(&quot;%d&quot;, &amp;N);
    for ( i=0; i&lt;N; i++ )
        scanf(&quot;%f&quot;, &amp;A[i]);
    printf(&quot;%.2f\n&quot;, Median(A, N));
    return 0;
}
/* 你的代码将被嵌在这里 */
输入样例：
3
12.3 34 -5
输出样例：
12.30
</code></pre></blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>　　首先，因为题目给定中位数位置为<strong>序列中第⌊N/2+1⌋大</strong>，所以不用考虑序列长度为奇为偶。<br>　　其次，因为涉及到排序，而又不能直接调用库里面的排序算法，so,就自己手写排序代码。</p>
<ul>
<li>第一次尝试冒泡排序😀，最后一组数据，大N超时🤔<br><img src="image/buddy.png" width="545" height="200"><blockquote>
<p>(PS:强迫症表示很难受。)</p>
</blockquote>
</li>
<li>第二次快速排序，结果如上上上，给的数据是反快速排序的😓</li>
<li>第三次堆排序，AC😉😆<br><strong>具体代码请转移至我的<a href="https://github.com/lightingmoon/BlogResourceCode/tree/master/求自定类型元素序列的中位数">Github</a></strong>。</li>
</ul>
<hr>
<h3 id="下面复习-反正review和preview有个p的区别😏-一下堆排序"><a href="#下面复习-反正review和preview有个p的区别😏-一下堆排序" class="headerlink" title="下面复习(反正review和preview有个p的区别😏)一下堆排序"></a>下面复习(反正review和preview有个p的区别😏)一下堆排序</h3><p>　　堆是一种数据结构，它是一颗<a href="https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin">完全二叉树</a>，并且具备以下性质:</p>
<ul>
<li>每个节点的值都大于或等于其左右子节点，称为大顶堆;</li>
<li>每个节点的值都小于或等于其左右子节点，称为小顶堆。</li>
</ul>
<hr>
<h4 id="比如小顶堆"><a href="#比如小顶堆" class="headerlink" title="比如小顶堆"></a>比如小顶堆</h4><p><center><img src="image/lessHeap.svg" width="400" height="320"></center><br>将之映射成数组V，有如下:</p>
<p><center><img src="image/mapVector.svg" width="400" height="100"></center><br>则对于数组有，索引为i的节点：<br>$ V[i]\leq V[2 \ast i+1]且 V[i] \leq V[2 \ast i+2]$ <strong>(1)</strong>(对于小顶堆)</p>
<hr>
<p>堆排序算法描述如下:</p>
<ol>
<li>将无序序列构造成小顶堆(最终数组为非严格降序排列，大顶堆反之)，如上图。<ul>
<li>具体构造过程如下:</li>
<li>对每个根节点进行判定，如果其不满足小顶堆定义，则交换元素，直至满足<strong>$(1)$</strong></li>
</ul>
</li>
<li>将第一个元素与最后一个元素交换，将最小元素下沉到数组最后，调整堆结构，使其满足定义。</li>
<li>反复执行2过程，直到数组有序。</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>C++代码实现：</p>
<pre><code>void HeapAdjust(ElementType A[], int x, int len)
{
    ElementType temp = A[x];        // 保存根节点x
    // 从x节点的左子节点开始
    for(int j = 2 * x + 1; j &lt; len; j = 2 * j + 1)    
    {
        if(j + 1 &lt; len &amp;&amp; A[j] &gt; A[j + 1])    // ，滑向值小的节点
            j++;
        if(temp &lt; A[j])            // 如果当前根节点小于子节点，则跳出循环
            break;
        A[x] = A[j];            // 子节点覆盖根节点
        x = j;                    // 此时子节点j变成根节点
    }
    A[x] = temp;                // 将x节点放在最终位置
}
ElementType HeapSort( ElementType A[], int N )
{
    // 构建初始堆，从第一个非叶子节点自底向上调整堆
    for(int i = N / 2 - 1; i &gt;= 0; i--)
    {
        HeapAdjust(A, i, N);
    }
    // 堆调整、交换元素
    for(int i = N - 1; i &gt; 0; i--)
    {
        // 元素下沉操作    
        ElementType temp = A[0];
        A[0] = A[i];
        A[i] = temp;
        // 调整整个堆
        HeapAdjust(A, 0, i);
    }
}
</code></pre><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h5 id="初始化堆"><a href="#初始化堆" class="headerlink" title="初始化堆"></a>初始化堆</h5><p>　　因为初始化堆是自底向上的，从最后一个非叶子节点开始调整堆(叶子节点不用调整😅)。可证明完全二叉树的最后一个非叶子节点的编号为$n/2-1$（$n$表示堆的元素总数量），这样从下至上，从右至左调整堆。<br>假设在第i层，二叉树高度为K,该层的节点数为<strong>$2^{i-1}$</strong>,调整该层需要的比较次数为<strong>$k-i$</strong>,<br>最后一个非叶子节点所在层数为$k-1$,则i的区间为$[1,k-1]$,每一层的比较次数:    </p>
<script type="math/tex; mode=display">s=2^{i-1}*(k-i)</script><p>所以初始化堆总的比较次数为： </p>
<script type="math/tex; mode=display">　①　 S = \sum_{i=1}^{k-1}2^{i-1}\ast(k-i)</script><p>该等式两边$\ast$2，得： </p>
<script type="math/tex; mode=display">　②　 2*S = \sum_{i=1}^{k-1}2^{i}\ast(k-i)</script><p>上两式$②　　-　①$ 得： </p>
<script type="math/tex; mode=display">S = \sum_{i=1}^{k-1}2^{i} - (k-1)</script><p>由等比数列公式<script type="math/tex">\frac{a_{1}(q^{n}-1)}{q-1}</script>得</p>
<script type="math/tex; mode=display">S = 2^{k}-k-1</script><p>k为二叉树的高度，$k=logn,2^{k}=2^{logn}=n$(对数恒等式),得到<script type="math/tex">S=n-logn-1</script>，所以初始化堆的时间复杂度为<strong>$O(n)$</strong></p>
<h5 id="调整堆"><a href="#调整堆" class="headerlink" title="调整堆"></a>调整堆</h5><p>　　下沉元素时，每一次调整堆都是从根节点调整的，也就是从第1层到k-1层，比较次数$log(i)$,而一共要进行n-1次，所以总的比较次数$(n-1)logn$(可以参考一下<a href="https://www.programiz.com/dsa/heap-sort">https://www.programiz.com/dsa/heap-sort</a>)，即$nlogn-logn$。所以调整堆的时间复杂度为<strong>$O(nlogn)$</strong></p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>　　作为原地排序(原地排序指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序)的一员，其空间复杂度为$O(1)$。</p>
]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>堆排序</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>用遗传算法解决一个简单问题</title>
    <url>/GeneticAlgorithm.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　学习算法，就我看来，其实就是学习解决问题的一种思想或者方法，应该是一种体验过程的学习，在过程中感悟与升华，最终把它吸收转化成自己的独特的思想；在学习中感受与惊叹先贤的解决问题的思想，未尝不是一种乐趣?这不也昭示了学习本身就是快乐的过程吗？如果连学习都体验不到快乐，那还有什么能体验到快乐呢？<br>　　本文是可以作为遗传算法介绍性文章，是关于一次简单、浅显的利用遗传算法来解决函数优化问题的介绍性文章。<br><a id="more"></a></p>
<h1 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h1><blockquote>
<p>求解函数 <script type="math/tex">f(x)=x*sin(10\pi +x)+1.0</script> 在区间<script type="math/tex">[-1，2]</script>的最大值。</p>
</blockquote>
<h1 id="知识准备"><a href="#知识准备" class="headerlink" title="知识准备"></a>知识准备</h1><p>　　首先列举一下遗传算法的构成要素</p>
<h3 id="1-染色体的编码以及编码方法"><a href="#1-染色体的编码以及编码方法" class="headerlink" title="1.染色体的编码以及编码方法"></a>1.染色体的编码以及编码方法</h3><p>　　我们要把问题的解空间进行编码，以便于遗传算法能进行操作。编码方式主要有二进制编码，浮点数编码，格雷码等。</p>
<h5 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h5><p>　　假设参数范围为<script type="math/tex">[A,B] (A<B)</script>,我们有长度为a的二进制串来编码，则共有<script type="math/tex">2^a</script>种不同编码，可以将<script type="math/tex">[A,B]</script>分成<script type="math/tex">2^a-1</script>份，等分长度为<script type="math/tex">α</script>，</p>
<hr>
<p><center><img src="image/example.png" width="300" height="200"/></center></p>
<hr>
<p>因为当二进制串长度过长时会影响遗传算法的运行效率，所以这类问题就要重新考虑编码方式了。</p>
<h5 id="浮点数编码"><a href="#浮点数编码" class="headerlink" title="浮点数编码"></a>浮点数编码</h5><p>　　对于函数优化问题，例如本题，浮点数编码则更合适了。浮点数编码就是用在一定范围内的浮点数表示每个个体的染色体。</p>
<h5 id="格雷码"><a href="#格雷码" class="headerlink" title="格雷码"></a>格雷码</h5><p>　　其是一种绝对编码的格式，是具有反射特性和循环特性的单步自补码。这些特性保证了它不会出现重大错误。因为它的每次变化都只有相邻两位发生变化，即每次变化与上一次都只有一位不相同。而自然二进制串在向高位进位时却<strong>至少有$1$位不同</strong>。相比于改变多位，明显格雷码的改变一位更稳定些，且出错几率也更小些。其构造方法：</p>
<hr>
<p>以二进制$0$为第$0$项，第$1$项改变最右边的位，第二项改变右起第一位非$0$的位的左边那一位，第三项改变最右边的位…如此反复，即可得到<script type="math/tex">n</script>位的Gray code.</p>
<hr>
<h3 id="2-群体初始化以及计算个体适应度"><a href="#2-群体初始化以及计算个体适应度" class="headerlink" title="2.群体初始化以及计算个体适应度"></a>2.群体初始化以及计算个体适应度</h3><p>　　适应度函数是评估个体的适应性的唯一标准，也是后面选择个体阶段的唯一标准。对于很多问题可以直接将目标函数作为适应度函数。遗传算法的目标函数不受连续可微的约束且定义域可以是任意集合。但对适应度函数有一个要求：针对输入可以计算出的、能加以比较的结果，必须是非负的。</p>
<h3 id="3-遗传算子-操作算子"><a href="#3-遗传算子-操作算子" class="headerlink" title="3.遗传算子(操作算子)"></a>3.遗传算子(操作算子)</h3><h5 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h5><p>　　根据个体的适应度选择进入下一代的个体，个体的适应度越大，则其越有可能被选入下一代。选择机制有轮盘赌方法，最佳个体保存法、期望值方法、排序选择方法、联赛选择方法、排挤方法等。一般都采用轮盘赌方法。下面描述一下轮盘赌算法：</p>
<hr>
<p>1.设种群数量为n，先计算出种群内所有个体适应度<script type="math/tex">f(x_{i})</script>，<br>再计算出种群总适应度<script type="math/tex">sum=\sum\limits_{i=0}^{n-1}f(x_{i})</script>，<br>个体适应度与种群总适应度的比值得到个体选择概率<script type="math/tex">\large p(x_{i})=\frac{f(x_{i})}{sum}</script>。<br>积累概率<script type="math/tex">q_{i}=\sum\limits_{j=0}^{n-1}p(x_{i})</script>表示从第一个个体的选择概率累加，累加到某项即为相应染色体的积累概率。<br>2.生成一个随机数<script type="math/tex">r</script>，若<script type="math/tex">r\leq q_{0}</script>,则选中<script type="math/tex">0</script>号染色体;<br>3.若<script type="math/tex">q_{i-1}<r\le q_{i}(1\leq i<n)</script>，则<script type="math/tex">i</script>号染色体被选中。<br>对于积累概率，如下图先给出个体选中概率:</p>
<p><center><img src="image/selectionProb.png" width="300" height="200"/></center><br>由图得积累概率:<br>$q(x<em>{0})=0.2$<br>$q(x</em>{1})=0.3$<br>$q(x<em>{2})=0.7$<br>$q(x</em>{3})=1$<br><strong>染色体的选择概率越大，在上面饼图占的比例也就越大，被选入下一代可能性也就越大</strong><br>轮盘赌选择算子在个体较少时，可能会出现不正确的反映个体适应度的选择过程，即适应的高的个体可能被淘汰了。此时就要考虑其他的选择算子。</p>
<hr>
<h5 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h5><p>　　交叉算子即把两个亲代个体的部分结构进行替换重组而生成新子代个体的操作。其两个特点：</p>
<ul>
<li>设计的交叉算子必须保证亲代的优良性状能在子代个体中得到遗传和继承。</li>
<li>交叉算子的设计与问题的编码是相互协调的，即编码-交叉设计。</li>
<li>对于二进制串编码，交叉算子主要有一点交叉，两点交叉，多点交叉，一致交叉。其中一点交叉的操作如下：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">个体</th>
<th style="text-align:center">对应编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$P_{1}$</td>
<td style="text-align:center">01010010</td>
</tr>
<tr>
<td style="text-align:center">$P_{2}$</td>
<td style="text-align:center">00101110</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>假设从左起第$5$位开始进行一点交叉，得到</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">个体</th>
<th style="text-align:center">取出的二进制串</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$P_{1}$</td>
<td style="text-align:center">0010</td>
</tr>
<tr>
<td style="text-align:center">$P_{2}$</td>
<td style="text-align:center">1110</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>进行一点交叉后得到两个新个体，</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">个体</th>
<th style="text-align:center">对应编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$P_{1}’$</td>
<td style="text-align:center">00101110</td>
</tr>
<tr>
<td style="text-align:center">$P_{2}’$</td>
<td style="text-align:center">01010010</td>
</tr>
</tbody>
</table>
</div>
<p>这样就完成了一次一点交叉运算。</p>
<ul>
<li>对于实数编码，主要采用算术交叉算子。假设存在个体$P<em>{1}$、$P</em>{2}$，对于它们进行算术交叉后得到新个体$P<em>{1}’$、$P</em>{2}’$的运算如下,其中伪随机数$\lambda$$\in$[0,1]：</li>
</ul>
<hr>
<p>$\large P<em>{1}’=\lambda P</em>{1}+(1-\lambda) P<em>{2}$<br>$\large P</em>{2}’=(1-\lambda) P<em>{1}+\lambda P</em>{2}$</p>
<hr>
<h5 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h5><p>引入变异算子有两个目的：</p>
<ul>
<li>使遗传算法具备局部搜索能力。当遗传算子通过交叉算子接近最优解领域时，变异算子可以使遗传算法快速向最优解收敛。在这种情况下，变异概率应取较小的值。</li>
<li>使种群具备较好的群体多样性，防止遗传算法出现未成熟收敛情况。此时，比那一概率应取较大的值。</li>
</ul>
<hr>
<p>1.对于二进制编码，其变异方式为随机的选择某些基因位，对这些基因位进行概率性的翻转变异，即$0$变为$1$,$1$变为$0$。<br>2.对于实数编码，其变异方式为随机变异。使变异个体变量分量加上一个伪随机数，该随机数为均匀分布或高斯分布。<br> 变异方式还有逆转变异算子，自适应变异算子等。</p>
<h5 id="遗传算子的性质"><a href="#遗传算子的性质" class="headerlink" title="遗传算子的性质"></a>遗传算子的性质</h5><p>　　交叉算子具备良好的全局搜索能力，是遗传算法的主要操作算子；变异算子具备局部搜索能力，是遗传算法的辅助操作算子。交叉和变异使遗传算法具备均衡的全局搜索能力和局部搜索能力。</p>
<h3 id="回到上面的问题，"><a href="#回到上面的问题，" class="headerlink" title="回到上面的问题，"></a>回到上面的问题，</h3><p>　　对于这个问题，我采取浮点数编码，下面是遗传算法的运行参数：</p>
<pre><code>const double PI = 3.1415927;                 // π
#define N 50                                  // 群体规模
#define T 100                               // 进化代数
#define PC  0.75                              // 参加交配概率
#define PM 0.0875                            // 变异概率
</code></pre><p><strong>完整实现代码请移至我的<a href="https://github.com/lightingmoon/BlogResourceCode/tree/master/GeneticAlgorithm">Github</a></strong></p>
<hr>
<p>　　说一下感想，对于解决问题的范式，无外乎就是从所有可能解决问题的方法中将这个方法找出来，也即搜索。最开始我们有广度搜索和深度搜索，它们都可能在有限时间内搜索到问题的解决方法。但是，它们是盲目搜索，在今天的计算机条件下，一来计算机能表示的状态空间有限，二来其运行速度对一些状态空间稍微大一些的问题，往往要花大量的时间去计算。所以睿智的前人就发明了启发式搜索，通过预先设置一些方法，引导搜索的方向，使它能更快速的进行搜索，得到更满意的答案。根据达尔文进化论，物竞天择，适者生存，不适者淘汰。我们有一种思想叫做类比，既然大自然能淘汰掉不适合生存其中的物种，保留适合的物种，那我们是否可以借鉴这种方式，淘汰掉不合适的搜索路径，留下适合的搜索路径，这样最后得到的就是最佳解决路径了。这就是遗传算法的本质了。这里只是见到了它的冰山一角而已。就当做领略风光了。</p>
<hr>
<h4 id="另外，在这里总结一下c语言获取伪随机数方法"><a href="#另外，在这里总结一下c语言获取伪随机数方法" class="headerlink" title="另外，在这里总结一下c语言获取伪随机数方法"></a>另外，在这里总结一下c语言获取伪随机数方法</h4><p>1.先设置伪随机数种子</p>
<pre><code>srand((int)time(0));
</code></pre><p>2.其次，获取随机数，假如要在子函数里生成随机数，则只能在主函数里设置随机数种子。也就是只用在主函数最开始设置一次种子就可以了。<br>下面是获取伪随机数的一般形式：</p>
<pre><code>rand()%y + x
</code></pre><p>表示生成$[x,y+x)$的伪随机整数。<br>如果需要闭区间$[x,y+x]$的话，可以再给y加个1，即</p>
<pre><code>rand()%(y+1) + x
</code></pre>]]></content>
      <categories>
        <category>优化算法</category>
      </categories>
      <tags>
        <tag>遗传算法</tag>
      </tags>
  </entry>
  <entry>
    <title>页置换算法之LRU(最近最久未使用)</title>
    <url>/LRUalgorithm.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近在做操作系统上机实验。有一个关于页置换算法的实验，实验所给的代码是先进先出调页算法，一时手痒就想着自己模拟一下LRU调页算法，就作为一个小开始吧。<br><a id="more"></a></p>
<h3 id="1-关于LRU算法"><a href="#1-关于LRU算法" class="headerlink" title="1.关于LRU算法"></a>1.关于LRU算法</h3><p>　　算法步骤描述如下:</p>
<ol>
<li>为所有的页添加一个计数器并置0。</li>
<li>若系统访问的页存在于内存中，为该页的计数器加一，并对内存中所有的页按计数器大小降序排列；否则执行第三步。</li>
<li>判断系统内存页数是否已满，是则将内存中排序最后一页置换为系统访问的页，并为该页初始化计数器；否则将系统访问的页加入内存，并初始化计数器。</li>
</ol>
<h3 id="2-关于数据结构"><a href="#2-关于数据结构" class="headerlink" title="2.关于数据结构"></a>2.关于数据结构</h3><p>　　1. 页类型可用如下结构体表示</p>
<pre><code class="lang-C++">struct page
{
    int pageNum = -1;    // 系统访问页码,默认-1为空
    int time = 0;       // 系统在内存访问总次数，默认为0次
    page() {}                                       // 空无参构造
    page(const int p): pageNum(p) {}                // 构造函数
    friend bool operator&lt;(page &amp;p1, page &amp;p2)       // 排序比较器
    {
        return p1.time &lt; p2.time;
    }
};
</code></pre>
<p>　　2. 可用一个最大空间为3的vector模拟内存</p>
<pre><code class="lang-C++">#define CAPACITY 3
std::vector&lt;pageNode&gt; mainMem;
</code></pre>
<h3 id="3-调页函数"><a href="#3-调页函数" class="headerlink" title="3.调页函数"></a>3.调页函数</h3><pre><code class="lang-c++">void foldPage(int page, std::vector&lt;pageNode&gt; &amp;mainMem)
{
    if(CAPACITY == mainMem.size())              /* 内存存放的页满,置换最后一页*/
    {
        mainMem.back().pageNum = page;
        mainMem.back().time = 0;
    }
    else
    {
        mainMem.emplace_back(page);             /* emplace_back()直接调用其构造函数，并加在vector最后。*/
    }
}
</code></pre>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><pre><code class="lang-html">模拟访问页面走向
4, 3, 2, 1, 4, 3, 5, 4, 3, 2, 1, 5, 1, 4, 3
-------------------------------------
时间  访问页   内存状态  缺页中断 调入页
0        
1       4        4           +      4
2       3        4 3         +      3
3       2        4 3 2       +      2
4       1        4 3 1       +      1
5       4        4 3 1
6       3        4 3 1
7       5        4 3 5       +      5
8       4        4 3 5
9       3        4 3 5
10      2        4 3 2       +      2
11      1        4 3 1       +      1
12      5        4 3 5       +      5
13      1        4 3 1       +      1
14      4        4 3 1
15      3        4 3 1
缺页中断次数为9
缺页率9/15=60.00%%
</code></pre>
<h3 id="完整测试代码见我的Github。"><a href="#完整测试代码见我的Github。" class="headerlink" title="完整测试代码见我的Github。"></a>完整测试代码见我的<a href="https://github.com/lightingmoon">Github</a>。</h3><p>————————————————————————————————————————————————我是分割线——————————————————————————-<br><strong>更新于2020.2.28</strong></p>
<h2 id="上面的构想还是学生时代初期的构想，太过于理想化，只考虑到了模拟，其它一概不考虑。真是一颗傲娇的心。"><a href="#上面的构想还是学生时代初期的构想，太过于理想化，只考虑到了模拟，其它一概不考虑。真是一颗傲娇的心。" class="headerlink" title="上面的构想还是学生时代初期的构想，太过于理想化，只考虑到了模拟，其它一概不考虑。真是一颗傲娇的心。"></a>上面的构想还是学生时代初期的构想，太过于理想化，只考虑到了模拟，其它一概不考虑。真是一颗傲娇的心。</h2><p>最近在<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/">LeetCode</a>上刷题，遇到了一道关于设计实现LRU算法的题，才发现当年写的LRU算法真是只有当年才能写出来。<br>　　真正在页置换算法应用实现中是根本不会为页设置访问次数属性并由该属性进行排序的，这效率低且浪费内存。光时间复杂度就高达O(nlogn)，更别提空间复杂度了。<br>下面开始分析优化：<br>　　在页置换算法中，没有必要对工作集内的页进行按访问次数排序，从而得到最近最少访问次数。而是因为我们只要求得到最近最少访问的页，只用<strong>将经常访问的页放到页表首部</strong>，则每次都能以O(1)的时间复杂度访问；而当调入新的页时，若OS为进程分配的页帧已用完，采用LRU算法，应删除最近最少访问的页，也就是页表尾部页；若页帧没有用完，则直接将新页加入到页表首部。这里这样描述是因为这个LRU算法实现基本就是这个思想。<br><strong>由以上，要以O(1)删除尾部元素，以O(1)插入元素到表首，以O(1)查找某元素(hash)，且有顺序(list)。综上分析，形成了新的数据结构——哈希链表。</strong><br>　　当时在LeetCode上接触这道题时，感觉思维被打乱了，甚至没读懂题意。后来看了题解才恍然大悟。也触摸到了分析这种题的一些诀窍。下面是cpp代码：</p>
<pre><code class="lang-c++">#include&lt;iostream&gt;
#include&lt;list&gt;
#include&lt;unordered_map&gt;

using namespace std;
// 哈希链表
class LRUCache
{
public:
    LRUCache(int capacity):_capacity(capacity) {}
    int get(int key)
    {
        auto it = mp.find(key);                 // C++11中迭代器类似于指针
        if(it == mp.end())
            return -1;

        int val = it-&gt;second-&gt;second;           // 取出key对应的value
        cache.erase(it-&gt;second);                //从cache中删除k-v
        cache.push_front(make_pair(key,val));   // 重新构造k-v放入cache头
        mp[key] = cache.begin();                // 更新该key hash映射的迭代器
        return val;
    }

    void put(int key, int value)
    {
        auto it = mp.find(key);
        if(mp.end() == it)                      // k-v不存在
        {
            if(cache.size() == _capacity)       // cache 已满，删除尾部，清理出空间
            {
                auto temp = cache.back();
                cache.pop_back();
                mp.erase(temp.first);           // 删除尾部的key在hash中对应的结点
            }
        }
        else   cache.erase(mp[key]);            // k-v存在,更新value,并放入cache头

        cache.push_front(make_pair(key,value)); // 将结点直接加入头部
        mp[key] = cache.begin();                // 更新该key对应的迭代器
    }
private:
    unsigned int _capacity;
    list&lt;pair&lt;int,int&gt;&gt; cache;                  // 模拟cache双链表
    unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; mp;    // hash表
};

int main()
{
    LRUCache cache(2);
    cache.put(1, 1);
    cache.put(2, 2);
    cout&lt;&lt;cache.get(1)&lt;&lt;endl;       // 返回  1
    cache.put(3, 3);    // 该操作会使得密钥 2 作废
    cout&lt;&lt;cache.get(2)&lt;&lt;endl;       // 返回 -1 (未找到)
    cache.put(4, 4);    // 该操作会使得密钥 1 作废
    cout&lt;&lt;cache.get(1)&lt;&lt;endl;       // 返回 -1 (未找到)
    cout&lt;&lt;cache.get(3)&lt;&lt;endl;       // 返回  3
    cout&lt;&lt;cache.get(4)&lt;&lt;endl;       // 返回  4
    return 0;
}
</code></pre>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>LRU</tag>
        <tag>页置换算法</tag>
      </tags>
  </entry>
  <entry>
    <title>致你我</title>
    <url>/BehaveMyself.html</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码，查看文章。</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="500febbd0389e3e879d0ccc42b7a9dc70a10c4060ea6b1e8051a1f4645e0d1e7">e378a21df03967215d4882ac498a8c4747b3be56619baea1a4420b26742222c8de32b9f6d6b63cd440592388713363cbff10cc0917593bc0d2cae3c31b4afaaf0e874d16b92441c67b4d1205892aa92f8880d07fd31671d8a022a2d2effed1a986559ca129965b33f1b110818f7f9eb892e7f77e2f3f413b64e026d3550493dc6f7af4b979b4d511147569d3682055102adc6952af72ad2a0f48eb6678898bdd530a78ec4b89a8537df71b2d93b7d4733de7f84a2f2bd5abd2fbab178a7107cb58cf106a1afa94facb6f8223efd9f83d14cc43b38a56df74d7fc48c6555fbe7a583ab5a2436c0cb3485bc413077af13f1df4a1b05df5e5d1a61b29e4c78ce6f5fe310b7072e4ff4670cd6ea411421c5288cdfddf1b74dae8e534b84e1c16acaecb040a90a46a808df286daa0cb91d531331315f51e90aaf1641499462d5215bb182acd36bfdcf280c13c462425959f220c345f6583b593e01b7c68dc6b58cf7c5810f59134e93a9f20086c1253c203b47c0751f334e993b93116dc0a1e0306b239a924a81f256e2c84f534a02705d6ad3aa8d487eadef2961e3642a902f70c9720e99a82749a029cee71ebdcda49d76737549764dc28d692d9f8fec95eb5646fc22f4b5d23cb37f1f4a454887e49da9a8f4e0390590636ca017b82044d0509fa820427d384c4d12d272eb8f5def97c4026be7563b3fda0e1487d4e5ee95eca583f7ce66ec8f73a4ccb1973c9b2d3758260d628640ab19fbab9fb6ee971cbcd88c247bb0de143906fcb103679b267f8af5f2611de0016eb04da1e4f6d1530f2776a23679ef91ab119314f53d6ba07ce617e17397ebf3729b44b0911706947ce9bd86ef5f81ec0e93c8138d8443c4c11f5acce252054807b7d3c5b3eeccf2c55a41de983baf219e11fdb6a3e7b1bc7d14391f3a46ab73f8a0868720b058431847a482f7206a4e849078f302f8ac6ea3bfdc61d97587382bf3889a9884f7cee2ac26d2bac4348f72f6dfae89e13c90e9f46ab22818270d5138e6f6116adb38a2834e2aa93acd290b53b62a422c71b37d143a584d0367519056925656403ba1bc2320d83e8ae0b3b8259a72a34d36ea2ba4b8396121f8da7a8cf57792f883467484dd774a267c6974cc05123493de51d84ffd6ada75c026f97e6016afa1400c71929930b68d56402f11d6dfaf6d23756d9d174bbe33d1e26a78d7c7c31f03af7caed2b65600112f27c721036f00e9271a1d3d95344e40eadd9d7dad83b4b0d6c124e38b341147f0d900eac1b1f87ceaf924516cd3d192ba17b78ce5f922c537078c802e0f6f39771c88e6b08600dc56bf0b6fee1efdafb6c01e6bbcb161546411b66877e930b5c6ec8fce92b6ada4e20e03bdf055d0d80fe309b7785763aca229757d2b668febb9f3d719ea34e973db6d0a7be61d9dc479079d51539ebb3bb21470e8e365be34ff30e2b8f5ff27dc027bf427c5e75661239b3a298fe4df8b236e5ece68b57c974625010f7fc2bb8a4ed9101f2dc7c3b3ed52b221337c36a683d840d0d013a8422b3dc322d4db1d193ea98b3f2b99a1a11503c3a2ce48a1512416bfde56746664847d5a68193c7d85cab9066d98ec1593a0eb97c6caf4e2243feda611c50a48db4662eb93d992ec64ba895a8ea24411ca9fa0d3ce1f26ed132b928e68cc2f418f22c08f13be27d606322ba1f5143276818c279a7617927d3cc279c28ffbeb04d43ef61378bb82abf0ad52ae7d144452aa8cbc9f900b59abbddec6747c5364b56e06cffea9aa0308fc2d81b5a366f8364e6781e9bb3a012969a96db6bee36b0b1b5047e4a2bed84d91d5a9e344b7deffb386e05e569a59e571965ddc9cccd8a70b243c0afbdb757a2fd7d1ea978cd9af914b1adbbb2b115d5314be72ccce5d8d974179a08129d10e55ed1129a9cd85345cb2bb06bf013a478edc974a4b5f5569b70bdd9bb9bb7c57cae514ee9686ea41b079b1ebf9c145fc9f23fa13fc72ed6d9a1fa23296e8d2d944a5bda1e26733be35adc5e5b2006b1386172a029ccff28186b9a857d8f124849b6786870e8cbbc507d0fbf8419758ef557bd051e7e7f98bcf28e35515638abeeae6eb51585fce4bbd5dc3cfc1573c242a683e53230d2bea219916afd1f071aee01301d9d0ab937b43d804405f7fdf51cb93e1908b6bf9f15352df198284d76558d775a0f42a08f8caeea941b0e6db07c30cdb432714a254d2bdedfa5cc1091b95930c51b804a0cc7c446644d2894fb4423214a06632b9e6ce3362d4f9522f09a7630c715be2d99d5a74b6d490ce7c8e175c129d8761c5645685503a5768dc69bbf2fd57b686d5a68b646465b308c342fd5f268b446e5e821c720c84df544c3a0d14a8c319fe3b7268ff2a7d3297caeb8487019b11286ffa27ff25c7470e05cfe1b86ec6d2d26cb76813858ac9def392582c3ff067ac7f0306bf2fc907dc7ff128e324eb0bfcf078cff64a9509b0a6ca7f7b215ea1ea18c02ebe3cf9324d1bd5673d84836b92fd6728a78f6374c50a6a50d8ba347a075a3c2a3f8bb2d0d9e525b7e2dece78906a8784d2bd19ef7fcd309edae96a3f7ce8aa09b895b0990b30513543c095498c268acb0dceb42fc4466431821cb72022ccf69ed91be72d4f3188f7f2eaed465dbb7bb3fa89e9768739935e51a607c0f417135b4bd2d6ac8ea4da22feb344d47f2297e1ae5cb4faed331b4c7466751dd1d471c43def6d4d3d924cdcc4c0540fa0ef5777838d400ac110fa70ee72977f3000807c3e4e1c0349302f1a86dec3c39c30e6d706a7a03d8c492562042def87737bb767847f7c0624ef4f4f5627aa0</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>静夜思</category>
      </categories>
      <tags>
        <tag>静夜思</tag>
      </tags>
  </entry>
  <entry>
    <title>第14次CSP认证考试总结</title>
    <url>/TheReflectionof14thCSP.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　学而不思则罔，思而不学则殆。不会反思自己的人思想总是不会太深刻，而太过沉溺于幻想之中只会徒增失落。低头前进，全凭一身锐气，不撞南墙不回头；不如与知音进行一次彻夜长谈，回顾过去，展望未来。目极远眺，若许人或在招手。<br><a id="more"></a><br>　　回顾整场考试，节奏把握的还是不错的。但其中的三大问题，令人唏嘘：</p>
<pre><code>* 1.第二题没有仔细分析条件，再加上给的样例，直接将思想带偏到了预定的方向;
* 2.第三题题目比较长，在看题的时候没有标注一个重要条件，导致在写代码时将其忽略;
* 3.心里没有B Tree，幻想着能在第四，五题得一些分(竟然不是把在一个小时内将4，5题
* 　做出来，看来也不是没有B Tree)。
</code></pre><h4 id="下面展开进行分析，"><a href="#下面展开进行分析，" class="headerlink" title="下面展开进行分析，"></a>下面展开进行分析，</h4><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><pre><code class="lang-c++">问题描述
试题编号：
201809-2
试题名称：
买菜
时间限制：
1.0s
内存限制：
256.0MB
问题描述：
问题描述
　　小H和小W来到了一条街上，两人分开买菜，他们买菜的过程可以描述为，
    去店里买一些菜然后去旁边的一个广场把菜装上车，两人都要买n种菜，
    所以也都要装n次车。具体的，
    对于小H来说有n个不相交的时间段[a1,b1],[a2,b2]...[an,bn]在装车，
    对于小W来说有n个不相交的时间段[c1,d1],[c2,d2]...[cn,dn]在装车。
    其中，一个时间段[s, t]表示的是从时刻s到时刻t这段时间，时长为t-s。
　　由于他们是好朋友，他们都在广场上装车的时候会聊天，他们想知道他们可以聊多长时间。
输入格式
　　输入的第一行包含一个正整数n，表示时间段的数量。
　　接下来n行每行两个数ai，bi，描述小H的各个装车的时间段。
　　接下来n行每行两个数ci，di，描述小W的各个装车的时间段。
输出格式
　　输出一行，一个正整数，表示两人可以聊多长时间。
样例输入
4
1 3
5 6
9 13
14 15
2 4
5 7
10 11
13 14
样例输出
3
数据规模和约定
　　对于所有的评测用例，1 ≤ n ≤ 2000, ai &lt; bi &lt; ai+1，ci &lt; di &lt; ci+1,
    对于所有的i(1 ≤ i ≤ n)有，1 ≤ ai, bi, ci, di ≤ 1000000。
</code></pre>
<p>关注数据规模和约定这一句</p>
<blockquote>
<p><strong>ai &lt; bi &lt; ai+1，ci &lt; di &lt; ci+1</strong>  </p>
</blockquote>
<p>当时的我处在看完样例之后再看这个条件，而且是在我已经有思路的情况下，于是顺理成章的没有<strong>认认真真、仔仔细细</strong>地再去分析这个条件，按照错误的思路写出了错误的只过了样例的代码，本来还想再造一些样例的，但是此时信心爆棚的我哪还有心思…事后和室友聊了一下，听他用了两个队列做的（我此时心里是带一点慌的），我向他解释我的方法，而且我着重向他介绍我没有<strong>认认真真、仔仔细细</strong>分析过的那个条件。如果没有这个条件，那么我的思路就是错的，但是由于当时没有题面，语言表述又有限，便作罢…过了两天出成绩，<strong>冲动的惩罚</strong>来了——只得了样例的分，而此时的我竟然还没有意识到错误解读条件…看来我还挺偏执…<br><em>所以考试的时候没有仔仔细细的分析条件，那就只能下来分析了，晚矣晚矣~</em></p>
<blockquote>
<p><strong>ai &lt; bi &lt; ai+1，ci &lt; di &lt; ci+1</strong>  </p>
</blockquote>
<p>分析一下，也就是数据规格符合逻辑而已，输入的小H、小W休息时间分别不会重叠。满分代码已我放在我的<a href="https://github.com/lightingmoon">Github</a>。</p>
<h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><p>题面比较长，就不搬来了，<a href="http://118.190.20.162/home.page">链接</a>，其中有个条件：id属性大小写不敏感，coding时的确忘了这个条件，得了80分…不得不说运气还挺好…<br>在这里记录一下解决这道题中 <strong>后代选择器</strong>的思路：</p>
<pre><code>* 第一步，用一个数组记录每一行文档的**层级**(累加每一行文档前面“.”的个数)。
* 第二步，将要查询的标签解析分开存在一个vector里，遍历查找vector中每一个标签，
* 查找算法步骤如下：
    * 第一步，按照解析后的标签的层级从低到高，开始在文档中查找；
    * 第二步，每次查找遵循贪心原则，只保存找到的标签的最大的层级数，找到则进
    * 行下一步，没找到查找结束；
    * 第三步，继续查找下一层标签，但是找到的最大的标签的层数必须是小于上一层
    * 找到的标签层数，如是往复。    


**题目给的提示绝对是很重要的。贪心，是个好算法。**
</code></pre><p>　　一瞬间的失神，可能决定着沧海桑田，望三思而后行。</p>
]]></content>
      <categories>
        <category>静夜思</category>
      </categories>
      <tags>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title>从最少交换次数到交换排序</title>
    <url>/SwapSort.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>  像往常一样，每周几题。今天这道题<strong>(<a href="https://code.mi.com/problem/list/view?id=8">最少交换次数</a>)</strong>让我做了一次发散性的思考，先把题面搬过来，有收获的小伙伴可以进原题链接练练手。    </p>
<a id="more"></a>
<pre><code>最少交换次数
序号：#8
难度：非常难
时间限制：1000ms
内存限制：10M
描述
给出一个无序数列，每次只能交换相邻两个元素，  
求将原数列变成递增数列的最少交换次数。   
如：数列：2,3,1，交换3和1后变成：2,1,3；交换1和2之后变成：1,2,3。总共交换2次。

输入
逗号隔开的正整数数列

输出
正整数

输入样例
2,3,1
输出样例
2
</code></pre><p>  当时看到题面的第一个念头就是用归并排序求<strong>逆序对</strong>(多了解一些准没错)，但是仔细一看题面，只能交换相邻元素，归并排序，pass。转念一想，还有交换(冒泡)排序呀，每次只交换相邻元素，这是完全符合题意要求的。我的代码如下：</p>
<pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
#define LARGE_IO
using namespace std;

vector&lt;int&gt; split(const string &amp;t)
{
    vector&lt;int&gt; out;
    stringstream tstream(t);
    int temp;
    while(tstream&gt;&gt;temp)
    {
        out.push_back(temp);
        tstream.ignore(1);
    }
    return out;
}
int bubbleSort(vector&lt;int&gt; &amp;p)
{
    int len = p.size(),cnt=0;

    for(int i = 0; i &lt; len - 1; i++)              // 控制趟数
    {
        for(int j = 1; j &lt; len - i; j++)          // 控制比较元素
        {
            if(p[j-1] &gt; p[j])
            {
                swap(p[j-1],p[j]);                // &lt;algorithm&gt;算法库自带
                cnt++;
            }
        }
    }

    return cnt;
}
int main()
{
#ifdef    LARGE_IO
    ios::sync_with_stdio(0);
#endif
    string inputStr;
    vector&lt;int&gt; p;
    while(getline(cin,inputStr))
    {
        p = split(inputStr);
        cout&lt;&lt;bubbleSort(p)&lt;&lt;endl;
    }

    return 0;
}
</code></pre>
<p>关于冒泡排序，有一个优化：<br>  设想一个场景，数组[1,0,2,3,4,5,6,7,8,9]，第一趟只进行了一次有用的比较，数组就有序了，后面的比较都是枉然的。所以考虑加一个flag，只要存在交换，冒泡排序就继续进行下一趟，反之，排序结束。请读者自行完成代码。</p>
<p> <br><br><br><br><br><br><br><br>  当然，，，，，不可能。</p>
<pre><code class="lang-C++">int bubbleSort(vector&lt;int&gt; &amp;p)
{
    int len = p.size(),cnt=0;
    bool flag=1;                                // 交换标记
    for(int i = 0; i &lt; len - 1&amp;&amp; flag; i++)      // 控制趟数
    {
        flag = 0;
        for(int j = 1; j &lt; len - i; j++)          // 控制比较元素
        {
            if(p[j-1] &gt; p[j])
            {
                swap(p[j-1],p[j]);
                cnt++;
                flag = 1;                        // 存在交换置 真
            }
        }
    }
    return cnt;
}
</code></pre>
<p>总结:</p>
<pre><code>* 认真仔细看题面。失之毫厘，差之千里。
* 先不要急于思考代码的实现这种细节，而是思考算法与数据结构(深度思考)。
* 完成后考虑举一反三，一题多解，锻炼发散性思维(广度思考)。
</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>交换排序</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title>split函数实现</title>
    <url>/theConstructofSplit.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>字符串分割函数split,将一个字符串按给定的定界符delim分割成字符串数组。实现的方式多种多样，由浅入深，从易到难，开始分割…<br><a id="more"></a><br>实现的方式有以下3种:</p>
<ul>
<li>用cstring 库中的strtok函数实现</li>
<li>string类对字符串直接处理实现</li>
<li>正则表达式结合STL实现  </li>
</ul>
<h2 id="用strtok函数实现"><a href="#用strtok函数实现" class="headerlink" title="用strtok函数实现"></a>用strtok函数实现</h2><pre><code class="lang-c++">std::vector&lt;std::string&gt; split0(const std::string &amp;str, const std::string &amp;deli)
{
    std::vector&lt;std::string&gt; out;
    if(str.empty())
    {
        return out;
    }
    if(deli.empty())
    {
        out.emplace_back(str);
        return out;
    }
    // c_str()返回当前string对象的c 风格常量字符串,即const char *
    const char *del=deli.c_str();

    // 将str重新放入流中，再用char数组读取
    std::stringstream ot(str);
    char strTemp[str.size()+1];
    ot&gt;&gt;strTemp;

    char *p=strtok(strTemp,del);
    while(p != nullptr)
    {
        out.emplace_back(p);
        p = strtok(nullptr,del);
    }
    return out;
}
</code></pre>
<h2 id="用string类实现"><a href="#用string类实现" class="headerlink" title="用string类实现"></a>用string类实现</h2><pre><code class="lang-C++">std::vector&lt;std::string&gt; split1(const std::string &amp;str, const std::string &amp;deli)
{
    std::vector&lt;std::string&gt; out;
    if(str.empty())
    {
        return out;
    }
    if(deli.empty())
    {
        out.emplace_back(str);
        return out;
    }
    // 直接处理字符串
    std::string p=str;
    p+=deli;                                // 保证结尾有一个定界符
    size_t cur;                             // 记录处理过的子串
    while((cur = p.find(deli)) != std::string ::npos)
    {
        out.emplace_back(p.substr(0,cur));  // 截取分割子串

        p=p.substr(cur+deli.size());        // 向后滑动
    }
    return out;
}
</code></pre>
<h2 id="用std-regex实现"><a href="#用std-regex实现" class="headerlink" title="用std::regex实现"></a>用std::regex实现</h2><pre><code class="lang-c++">std::vector&lt;std::string&gt; split2(const std::string &amp;str, const std::string &amp;deli)
{
    std::vector&lt;std::string&gt; out;
    if(str.empty())
    {
        return out;
    }
    if(deli.empty())
    {
        out.emplace_back(str);
        return out;
    }

    // 构造定界符正则
    std::regex re(deli);

    // 获取匹配该定界符的串的前缀
    std::sregex_token_iterator p(str.begin(), str.end(), re, -1);
    std::sregex_token_iterator end;

    while (p != end)
    {
        out.emplace_back(*p++);
    }
    return out;
}
</code></pre>
<p>完整测试代码见我的<a href="https://github.com/lightingmoon">Github</a><br>参考资料:<br><a href="http://www.cplusplus.com/reference/regex/regex_token_iterator/regex_token_iterator/">C++ Reference</a><br><a href="https://www.cnblogs.com/qianlicao/p/9274444.html">几种c++字符串split 函数实现的比较</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++11</tag>
        <tag>split函数</tag>
        <tag>STL</tag>
        <tag>字符串分割</tag>
      </tags>
  </entry>
  <entry>
    <title>C++正则表达式库(std::regex)</title>
    <url>/C++std-regex.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><a href="https://code.mi.com/site/index">小米OJ</a>里的题有一个独特的数据输入方式，迫使我不得不去掌握一些高效处理字符串的方法，从正则开始。<br><a id="more"></a><br>知其所以然，请跳转　<a href="https://www.cnblogs.com/longhuihu/p/4128203.html">正则表达式之基本原理</a>。  </p>
<h3 id="std-regex"><a href="#std-regex" class="headerlink" title="std::regex"></a>std::regex</h3><p>　　其常用函数(类)如下</p>
<ul>
<li>regex_match() ，全词匹配。</li>
<li>regex_search()，搜索匹配。</li>
<li>regex_replace()，搜索匹配并替换。</li>
<li>std::regex_iterator，不分组多次全词匹配，可获取整个正则结果。  </li>
</ul>
<h4 id="regex-match（全词匹配）用法"><a href="#regex-match（全词匹配）用法" class="headerlink" title="regex_match（全词匹配）用法"></a>regex_match（全词匹配）用法</h4><pre><code class="lang-c++">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;regex&gt;
using std::cin;
using std::cout;
using std::endl;
int main()
{
    std::string s(&quot;122  622&quot;);
    std::regex e(&quot;(\\d+)(\\s+)(\\d+)&quot;);        // 两边各最少一个数字，中间至少一个空格
    // 是否全词匹配成功
    if (std::regex_match (s,e))
    {
        cout &lt;&lt; &quot;the match is successful!&quot;;
    }
    else
    {
        cout&lt;&lt;&quot;the match is failed!&quot;&lt;&lt;endl;
    }
    // 捕获匹配内容
    //std::match_results&lt;const char *&gt; cm;
    std::cmatch cm;             // 同于std::match_results&lt;const char *&gt;
    std::regex_match (s.c_str(),cm,e);
    cout &lt;&lt; &quot;string literal with &quot; &lt;&lt; cm.size() &lt;&lt; &quot; matches\n&quot;;
    for(auto y:cm)
        cout&lt;&lt;&quot;[&quot;&lt;&lt;y&lt;&lt;&quot;]&quot;&lt;&lt;endl;
    return 0;
}
</code></pre>
<p><strong>注:捕获的结果中，第一条一般都是字符串本身</strong><br>运行结果:</p>
<pre><code>the match is successful!
string literal with 4 matches
[122   622]
[122]
[   ]
[622]
</code></pre><h4 id="regex-search（搜索匹配）用法"><a href="#regex-search（搜索匹配）用法" class="headerlink" title="regex_search（搜索匹配）用法"></a>regex_search（搜索匹配）用法</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;regex&gt;
using std::cin;
using std::cout;
using std::endl;
int main()
{
    std::string s(&quot;sss666  333ff&quot;);
    std::regex e(&quot;(\\d+)(\\s+)(\\d+)&quot;);
    // 是否搜索匹配成功
    if (std::regex_search(s,e))
    {
        cout&lt;&lt;&quot;the match is successful!&quot;&lt;&lt;endl;
        // 捕获匹配内容
        std::cmatch cm;             // 同于std::match_results&lt;const char *&gt;
        std::regex_search(s.c_str(),cm,e);
        for(auto y:cm)
            cout&lt;&lt;&quot;[&quot;&lt;&lt;y&lt;&lt;&quot;]&quot;&lt;&lt;endl;
        }
    else
    {
        cout&lt;&lt;&quot;the match is failed!&quot;&lt;&lt;endl;
    }
    return 0;
}
</code></pre><p>运行结果:</p>
<pre><code>the match is successful!
[666  333]
[666]
[  ]
[333]
</code></pre><h4 id="regex-replace（搜索匹配并替换）用法"><a href="#regex-replace（搜索匹配并替换）用法" class="headerlink" title="regex_replace（搜索匹配并替换）用法"></a>regex_replace（搜索匹配并替换）用法</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;regex&gt;
using std::cin;
using std::cout;
using std::endl;
int main()
{
    // Flags used to control how rgx is matched and how fmt is formatted.
    std::regex_constants::match_flag_type fonly =
        std::regex_constants::format_first_only;

    std::string s(&quot;  sss666  333ffF  d32132  &quot;);
    // 由一个及以上的空格开始，接下来是1~3个数字或字母的组合
    std::regex rgx(&quot;(\\s+[a-z0-9]{1,3})&quot;);

    std::string fmt=&quot;&quot;;
    cout&lt;&lt;&quot;flags: &quot;&lt;&lt;std::regex_replace(s,rgx,fmt,fonly)&lt;&lt;endl;
    cout&lt;&lt;&quot;default: &quot;&lt;&lt;std::regex_replace(s,rgx,fmt)&lt;&lt;endl;
    return 0;
}
</code></pre><p>运行结果:</p>
<pre><code>flags: 666  333ffF  d32132
default: 666ffF132
</code></pre><h4 id="std-regex-iterator-（不分组多次全词匹配）"><a href="#std-regex-iterator-（不分组多次全词匹配）" class="headerlink" title="std::regex_iterator （不分组多次全词匹配）"></a>std::regex_iterator （不分组多次全词匹配）</h4><pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;regex&gt;
using std::cin;
using std::cout;
using std::endl;
int main()
{
   std::string s=&quot;31234a,333sss,3435ss.dwa&quot;;

    // 匹配以任意符号开始，接下来是一个及以上的数字与2个及以上小写字母的组合
    std::regex rgx(&quot;(\\d+[a-z]{2,})&quot;);

    // std::sregex_iterator == std::regex_iterator&lt;std::string::const_iterator&gt;
    std::regex_iterator&lt;std::string::const_iterator&gt; cbegin(s.begin(),s.end(),rgx);
    std::sregex_iterator cend;
    while(cbegin != cend)
    {
        cout&lt;&lt;cbegin-&gt;str()&lt;&lt;endl;
        cbegin++;
    }
    return 0;
}
</code></pre><p>运行结果:</p>
<pre><code>333sss
3435ss
</code></pre><p>参考资料:<br><a href="http://www.cplusplus.com/reference/regex/">Cplusplus reference</a><br><a href="https://blog.csdn.net/l357630798/article/details/78235307">Cpp标准库之 std::regex 类的使用</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>regex</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Win32网络编程</title>
    <url>/C++SocketTest.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近计算机网络课需要我们做一个图片传输程序，在客户端上传输图片至服务器，要求服务器能过滤文件并展示客户端上传的图片，我带着亲爱的“C++”，开着“百度”，开始畅游“网络”，并在这里写下总结。<br><a id="more"></a><br>TCP与UDP都是OSI(Open System Interconnection 开放式系统互联)参考模型下第四层——传输层协议，在这里总结一下它们的特点。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><strong>TCP</strong>(Transmission Control Protocol 传输控制协议)，是面向连接的。交互双方都建立一个流式套接字，服务器需要等待客户端连接，一旦连接上就立即返回一个新的套接字描述符，通过描述符调用数据传输函数与客户端进行数据的收发。  </p>
<ul>
<li>优点：可靠、稳定。  </li>
<li>缺点：速度慢、效率低、占用系统资源多、易被攻击。  </li>
<li>适合场景：网络通讯质量要求高的地方。    </li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><strong>UDP</strong>(User Datagram Protocol 用户数据报协议)，是面向无连接的。双方建立的都是数据报套接字，服务器与客户端在进行传描数据之前不需要进行连接的申请和建立，可随时向对方发送消息。  </p>
<ul>
<li>优点：速度快、比TCP稍安全  </li>
<li>缺点：不可靠，不稳定  </li>
<li>使用场合：网络通讯质量要求不高、速度快的场所。</li>
</ul>
<h2 id="TCP-IP三次握手"><a href="#TCP-IP三次握手" class="headerlink" title="TCP/IP三次握手"></a>TCP/IP三次握手</h2><p>这里有一段生动地描述，我摘抄如下:</p>
<blockquote>
<p>主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。  </p>
</blockquote>
<p>摘自百度百科<a href="https://baike.baidu.com/item/TCP/UDP%E5%8D%8F%E8%AE%AE/7719820">TCP/UDP协议</a>。经过这样三次对话，TCP才能建立稳定、可靠的连接，保证发送数据的正确性。<br><br></p>
<h2 id="C-实现TCP-IP三次握手，并在传输文件后关闭连接"><a href="#C-实现TCP-IP三次握手，并在传输文件后关闭连接" class="headerlink" title="C++实现TCP/IP三次握手，并在传输文件后关闭连接"></a>C++实现TCP/IP三次握手，并在传输文件后关闭连接</h2><p><strong>运行环境: VS 2017</strong></p>
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><pre><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
#include &lt;WinSock2.h&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#pragma comment(lib, &quot;ws2_32.lib&quot;)        // 导入动态链接库

SOCKET sockSrv;
void RecvFile();

int main(int argc, CHAR* argv[])

{
    WSADATA wsaData;
    int port = 8800;
    // 加载套接字
    if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0)
    {
        std::cout&lt;&lt;&quot;加载套接字失败: &quot;&lt;&lt; WSAGetLastError()&lt;&lt;&quot;......\n&quot;;
        return 1;
    } 
    sockSrv = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);    //    TCP/IP协议 
    // 初始化IP和端口信息
    SOCKADDR_IN addrSrv;
    addrSrv.sin_family = AF_INET;
    addrSrv.sin_port = htons(port);                            // 1024以上的端口号
    addrSrv.sin_addr.S_un.S_addr = INADDR_ANY;

    // bind()
    if (bind(sockSrv, (LPSOCKADDR)&amp;addrSrv, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
        std::cout&lt;&lt;&quot;套接字绑定失败：&quot;&lt;&lt; WSAGetLastError()&lt;&lt;&quot;......\n&quot;;
        return 1;
    }
    // listen()
    if (listen(sockSrv, 1) == SOCKET_ERROR)
    {
        std::cout&lt;&lt;&quot;套接字监听失败：&quot;&lt;&lt;WSAGetLastError()&lt;&lt;&quot;......\n&quot;;
        return 1;
    }
    // 客户端信息
    SOCKADDR_IN addrClient;
    int len = sizeof(SOCKADDR);
    // 开始监听
    std::cout&lt;&lt;&quot;服务端启动成功......开始监听...\n&quot;;
    while (1)
    {
        // 等待客户请求到来  
        sockSrv = accept(sockSrv, (SOCKADDR *)&amp;addrClient, &amp;len);
        if (sockSrv == SOCKET_ERROR) {
            std::cout&lt;&lt;&quot;建立连接失败：&quot;&lt;&lt;WSAGetLastError()&lt;&lt;&quot;......\n&quot;;
            break;
        }
        std::cout&lt;&lt;&quot;与客户端建立连接......IP：&quot;&lt;&lt;inet_ntoa(addrClient.sin_addr)&lt;&lt;std::endl;
        std::cout &lt;&lt; &quot;开始接受数据...&quot; &lt;&lt; std::endl;
        RecvFile();
        std::cout &lt;&lt; &quot;接受完毕&quot; &lt;&lt; std::endl;
        // 关闭套接字
        closesocket(sockSrv);
    }
    WSACleanup();
    system(&quot;pause&quot;);
    return 0;
}
void RecvFile() {
    const int bufferSize = 1024;
    char buffer[bufferSize] = { 0 };
    int readLen = 0;
    std::string desFileName = &quot;E:\\demo.jpg&quot;;   // 打开我的E盘的一个图片文件
    std::ofstream desFile;
    desFile.open(desFileName.c_str(), std::ios::binary);    // 以二进制文件方式，不然图片会乱码
    do {                    
        readLen = recv(sockSrv, buffer, bufferSize, 0);
        if (readLen == 0)                            // 循环接受文件，直到发送的文件为 EOF
        {
            break;
        }
        else
        {
            desFile.write(buffer, readLen);
        }
    } while (true);
    desFile.close();                    // 莫忘关闭文件
}
</code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code>#include &quot;pch.h&quot;
#include &lt;iostream&gt;
#include &lt;WinSock2.h&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#pragma comment(lib, &quot;ws2_32.lib&quot;)

SOCKET sockClient;
void SendFile() {
    std::streamsize haveSend = 0;
    const int bufferSize = 1024;
    char buffer[bufferSize] = {0};
    std::streamsize readLen=0;
    std::string srcFileName = &quot;E:\\upload\\universe.jpg&quot;;        // 打开E盘的一个图片文件
    std::ifstream srcFile;
    srcFile.open(srcFileName.c_str(), std::ios::binary);        // 以二进制文件打开
    while (!srcFile.eof()) {                                    // 当读到结尾时会多循环一次，以作为发送结束标志
        srcFile.read(buffer, bufferSize);
        readLen = srcFile.gcount();
        send(sockClient, buffer, readLen, 0);
        haveSend += readLen;
    }
    srcFile.close();
}

int main(int argc, CHAR* argv[])

{
    WSADATA wsaData;
    int port = 8800;
    // 加载套接字
    if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0)
    {
        std::cout &lt;&lt; &quot;加载套接字失败：&quot; &lt;&lt; WSAGetLastError() &lt;&lt; &quot;......&quot;&lt;&lt;std::endl;
        system(&quot;pause&quot;);
        return 1;
    }
    // 初始化IP和端口信息
    SOCKADDR_IN addrSrv;
    addrSrv.sin_family = AF_INET;
    addrSrv.sin_port = htons(port);
    addrSrv.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);
    // socket()
    sockClient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (SOCKET_ERROR == sockClient) 
    {
        std::cout &lt;&lt; &quot;创建套接字失败:&quot; &lt;&lt; WSAGetLastError() &lt;&lt; &quot;......&quot; &lt;&lt; std::endl;
        system(&quot;pause&quot;);
        return 2;
    }
    // 向服务器发出连接请求
    if (connect(sockClient, (struct sockaddr*)&amp;addrSrv, sizeof(addrSrv)) == INVALID_SOCKET)
    {
        std::cout &lt;&lt; &quot;连接服务器失败：&quot; &lt;&lt; WSAGetLastError() &lt;&lt; &quot;......&quot; &lt;&lt; std::endl;
        system(&quot;pause&quot;);
        return 3;
    }
    else
    {
        std::cout &lt;&lt; &quot;连接成功!\n\n&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;开始发送&quot; &lt;&lt; std::endl;
        SendFile();
        std::cout &lt;&lt; &quot;\n发送成功!&quot; &lt;&lt; std::endl;
    }
    // 关闭套接字
    closesocket(sockClient);
    WSACleanup();
    system(&quot;pause&quot;);
    return 0;
}
</code></pre><p>考虑在发送图片文件之前，给服务器发送一些该文件的信息，如名称，大小等，这样服务器可以精确的保存图片文件，诸如此类。<br>参考资料:<br><a href="https://www.cnblogs.com/bitor/p/9486892.html">windows环境下使用C++&amp;Socket实现文件传输</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树BST</title>
    <url>/BinarySearchTree.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>二叉搜索树(Binary Search Tree)又名二叉查找树、二叉排序树，它要么是一棵空树，要么满足以下条件:</p>
<ul>
<li>若其左子树不为空，则左子树所有节点的值小于根节点的值；</li>
<li>若其右子树不为空，则其右子树所有节点值均大于他的根节点的值；</li>
<li>其左右子树也为二叉查找树。    <a id="more"></a>    
<h3 id="一、-特点"><a href="#一、-特点" class="headerlink" title="一、 特点"></a>一、 特点</h3>　　通过中序遍历二叉搜索树可以得到一个有序的序列。另一方面，通过对一个序列构造二叉搜索树可以将其变为有序，构造构造过程即为排序过程。<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5>　　如果BST左右子树的节点数目保持平衡，即所有非叶子节点的左右子树数目差不多，则它的搜索性能堪比二分查找；二分查找应用于以连续内存空间存储且有序的数组，而以树这种数据结构存储时，对于插入节点和删除节点则比数组这种数据结构高效很多，甚至能达到常数时间。  <h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5>　　如果构造二叉搜索树时，没有选好根节点那么构造的二叉搜索树可能会成为这个样子，<br><center><img src="image/BSTDegenerate.svg" width="240" height="300"/></center><br>这样的结构则完全失去了二叉搜索树的优势。所以要尽量让二叉搜索树保持平衡，关于保持平衡就要涉及平衡二叉搜索树(AVL)，红黑树(RBT)等数据结构，本文先不介绍。<h3 id="二、实践"><a href="#二、实践" class="headerlink" title="二、实践"></a>二、实践</h3>　　以一个公司职员管理系统为例，其底层数据结构用二叉搜索树实现，具备增加加节点，删除节点，修改节点，搜索节点基本功能，主要是实践出真知。二叉树的一个节点也为一个职员，其节点类型如下：<pre><code>typedef struct Node
{
  struct Node *left = nullptr;            // 左子树指针
  struct Node *right = nullptr;            // 右子树指针
  string name;                        // 职员姓名
  string gender;                        // 职员性别
  string num;                            // 节点的关键字，为社保号，唯一
  string date;                            // 入职日期
  int salary = 0;                        // 薪资
  static int total;                        // 静态变量记录公司职员总人数。
  Node() {}
  Node(string na, string gen, string number, string da, int s)        // 构造方法
  {
      name.assign(na);
      gender.assign(gen);
      num.assign(number);
      date.assign(da);
      salary = s;
      total++;                            // 每构造一个对象总数加一
  }
  ~Node() {}
} Staff;
int Staff::total = 0;
</code></pre>下面是增、删、改、查的一些成员函数，分别用递归和非递归实现: <h4 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h4>　　即二叉搜索树增加节点，逻辑清晰：</li>
</ul>
<ol>
<li>判定二叉搜索树是否为空，是则直接加入新节点。否则执行第二步</li>
<li>将新节点的关键字与根节点的关键字相比，小于则进入左子树继续比较以寻找叶子节点并加入新节点，大于则进入右子树寻找加入新节点的位置，</li>
</ol>
<ul>
<li><strong>递归</strong><pre><code>void addStaff(Staff **r, string m[])        // 传递指针的指针，可在任何地方修改指针指向的地址的内容而不用返回被改变的根节点。
{
   if(nullptr == (*r))                     // 如果二叉搜索树或节点为空，直接添加新节点。    
   {
       *r = new Staff(m, m[1], m[2], m[3], atoi(m[4].c_str()));
       cout &lt;&lt; &quot;添加职员成功！&quot; &lt;&lt; endl;
       return;
   }
   if(m[2] &lt; (*r)-&gt;num)            // 关键字值小于根节点的关键字，新节点加在左子树里面
   {
       addStaff(&amp;(*r)-&gt;left, m);
   }
   else                            // 关键字值大于根节点的关键字，新节点加在右子树里面
   {
       addStaff(&amp;(*r)-&gt;right, m);
   }
}
</code></pre></li>
<li><strong>非递归</strong><pre><code>void addStaff(Staff **r, string m[])      // 传递指针的指针，可在任何地方修改指针指向的地址的内容而不用返回。
{
  if(r == nullptr)                    // 二叉搜索树为空，直接加入节点。
  {    
      *r = new Staff(m[0], m[1], m[2], m[3], atoi(m[4].c_str()));
      cout&lt;&lt;&quot;添加成功!&quot;&lt;&lt;endl;
      return;
  }
  while(r != nullptr)                
  {
     if(m[2] &lt; (*r)-&gt;num)            // 新节点关键字小于根节点，进入左子树寻找
      {
          r = &amp;(*r)-&gt;left;
      }
      else                            // 进入右子树寻找位置
      {
          r = &amp;(*r)-&gt;right;
      }
      if(nullptr == (*r))                
      {
          *r = new Staff(m[0], m[1], m[2], m[3], atoi(m[4].c_str()));
          cout&lt;&lt;&quot;添加成功!&quot;&lt;&lt;endl;
          break;
      }
  }
}
</code></pre><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4>　　删除节点情况稍微复杂一些，考虑一下：</li>
<li>要删除的节点只有左子树或右子树，或都没有：考虑删除的节点只有左子树，直接将其左子树赋给该节点：反之将右子树赋给该节点。如果删除的是叶子节点，则直接删除该节点(亦左子树或右子树都可以赋给它)。</li>
<li>要删除的节点既有左子树又有右子树，找出其右子树最小节点数据覆盖被删除的节点信息，并删除该最小节点。</li>
<li>递归<pre><code>int deleteStaff(Staff *&amp;r,string num)
{
  if(nullptr == r)        // BST为空
  {
      return -1;
  }
  if(r-&gt;num &gt; num)        // 搜索左子树
  {
      return deleteStaff(r-&gt;left,num);
  }
  else if(r-&gt;num &lt; num)   // 搜索右子树
  {
      return deleteStaff(r-&gt;right,num);
  }
  else
  {
      if(r-&gt;left == nullptr || r-&gt;right == nullptr)       // 删除的节点只有左子树或右子树
      {
          r = (r-&gt;left != nullptr)?r-&gt;left:r-&gt;right;
          return 1;
      }
      else
      {
          Staff *temp = r-&gt;right;      // 从右子树找一个最小节点并用它来代替被删除的节点，再删除该最小节点。
          while(temp-&gt;left != nullptr)
          {
              temp = temp-&gt;left;
          }
          // 覆盖信息
          r-&gt;name = temp-&gt;name;
          r-&gt;gender = temp-&gt;gender;
          r-&gt;num = temp-&gt;num;
          r-&gt;date = temp-&gt;date;
          r-&gt;salary = temp-&gt;salary;
          // 删除最小节点
          deleteStaff(r-&gt;right,temp-&gt;num);
          return 1;
      }
  }
  return -1;
}
</code></pre><h4 id="修改节点和查询节点"><a href="#修改节点和查询节点" class="headerlink" title="修改节点和查询节点"></a>修改节点和查询节点</h4>　　其原理和遍历二叉搜索树相似，直接介绍递归与非递归的中序遍历。<h4 id="中序遍历二叉搜索树"><a href="#中序遍历二叉搜索树" class="headerlink" title="中序遍历二叉搜索树"></a>中序遍历二叉搜索树</h4></li>
<li>递归<pre><code>void inOrderTraverse(Staff *r )      // 中序遍历BST
{       if(r == nullptr)
      {
          return;
      }
  if(r != nullptr) 
  {          // 递归中序遍历BST
      inOrderTraverse(r-&gt;left);
      cout &lt;&lt; r-&gt;name &lt;&lt; &quot;\t&quot; &lt;&lt; r-&gt;gender &lt;&lt; &quot;\t&quot; &lt;&lt; r-&gt;num &lt;&lt; &quot;\t&quot; &lt;&lt; r-&gt;date &lt;&lt; &quot;\t&quot; &lt;&lt; r-&gt;salary &lt;&lt; endl;
      inOrderTraverse(r-&gt;right);
      }
}
</code></pre></li>
<li>非递归<pre><code>void inOrderTraverse(Staff *r )      //非递归 中序遍历BST
{  
  if(r == nullptr)
  {
          return;
  }
  stack&lt;Staff*&gt; s;
  Staff *p=r;
  while(p != nullptr || !s.empty())   // 到叶子节点或栈空
  {
      while(p != nullptr)                // 先放入相对根节点，次放其左子树，直到左子树空
      {
          s.push(p);
          p = p-&gt;left;
      }                        
      if(!s.empty())                    // 访问节点：左、根、右
      {
          p = s.top();
          cout &lt;&lt; p-&gt;name &lt;&lt; &quot;\t&quot; &lt;&lt; p-&gt;gender &lt;&lt; &quot;\t&quot; &lt;&lt; p-&gt;num &lt;&lt; &quot;\t&quot; &lt;&lt; p-&gt;date &lt;&lt; &quot;\t&quot; &lt;&lt; p-&gt;salary &lt;&lt; endl; 
          s.pop();
          p = p-&gt;right;
      }
  }
}
</code></pre>完整职员管理系统请转移至<a href="https://github.com/lightingmoon/">我的Github</a>。如果有错误，万望能帮我指出来，不胜感激。</li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集入门</title>
    <url>/unionFindSet.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>在《算法基础》书中，<strong>并查集</strong>又被称为<strong>不相交集结构</strong>：假设有1到N个对象，希望将这些对象分成不相交的集合，在任意给定时间里，每个对象都恰好在一个集合里。对于每个集合，选择一个成员作为集合的标签。例如决定用最小的对象作为标签，可以用“集合2”来表示集合{2,5,7,10}。 抽象结束。<br><a id="more"></a><br>作为一个受益者，我强烈建议先看这篇　<strong><a href="https://blog.csdn.net/niushuai666/article/details/6662911">超有爱的并查集~</a></strong> 。　虽不能说是后无来者，但绝对是前无古人，能将知识讲得如此活泼有趣，清晰透彻。望洋兴叹，心向往之。所以在这里只谈一些总结。<br>先看题，<a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805117167976448">原题链接</a>  </p>
<hr>
<pre><code>当芸芸众生忙着在朋友圈中发照片的时候，
总有一些人因为太帅而没有朋友。  
本题就要求你找出那些帅到没有朋友的人。  
输入格式：  
输入第一行给出一个正整数N（≤100），是已知朋友圈的个数；  
随后N行，每行首先给出一个正整数K（≤1000）,  
为朋友圈中的人数，  
然后列出一个朋友圈内的所有人——为方便起见，  
每人对应一个ID号，为5位数字  
（从00000到99999），ID间以空格分隔；  
之后给出一个正整数M（≤10000），为待查询的人数；  
随后一行中列出M个待查询的ID，以空格分隔。  
注意：没有朋友的人可以是根本没安装“朋友圈”，  
也可以是只有自己一个人在朋友圈的人。  
虽然有个别自恋狂会自己把自己反复加进朋友圈，  
但题目保证所有K超过1的朋友圈里都至少有2个不同的人。    

输出格式：  
按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，  
行的首尾不得有多余空格。如果没有人太帅，  
则输出No one is handsome。  
注意：同一个人可以被查询多次，但只输出一次。  

输入样例1：  
3  
3 11111 22222 55555  
2 33333 44444  
4 55555 66666 99999 77777  
8  
55555 44444 10000 88888 22222 11111 23333 88888  

输出样例1：  
10000 88888 23333  

输入样例2：  
3  
3 11111 22222 55555  
2 33333 44444  
4 55555 66666 99999 77777  
4  
55555 44444 22222 11111    

输出样例2：  
No one is handsome
</code></pre><hr>
<p>这一题考虑用并查集做，现在考虑算法，可以将列举的每一个朋友圈的第一个人作为标签，并将这些标签加入set集合,以便于进行查询。另外再开一个数组为每一个ID置0，默认为未访问标记，查询过的标记置1,如是往复，直到查询结束，因为此题有大量查询语句，所以路径压缩是必须的。且这道题有一个细节：虽然ID号为5位数，但是输入与输出不处理的话，就不满足为5位数，例如00000，存入int型变量输出就会成为0（1位数），所以要固定占位5位，不足5位用0补足。下面是代码：</p>
<pre><code class="lang-C++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int pre[100003];
int visit[100003] = {0};
set&lt;int&gt; p;
int finder(int x)
{
    int r = x;
    while(pre[r] != r)
        r = pre[r];
    int y = x,z;
    while(pre[y]!= r){  // 路径压缩
        z = pre[y];
        pre[y] = r;
        y = z;
    }
    return r;
}
void join(int x, int y)
{
    int fx = finder(x);
    int fy = finder(y);
    if(fx != fy)  pre[fx] = fy;
}
int main()
{
    ios::sync_with_stdio(false);
    // 初始化前导节点
    for(int i = 0;i&lt;100003;i++)
        pre[i] = i;
    // 数据
    int n,m,k,id,rt;
    bool flag = true;
    cin&gt;&gt;n;
    while(n--){
        cin&gt;&gt;m&gt;&gt;rt;          //指定根节点
        for(int i = 1;i&lt;m;i++){
            cin&gt;&gt;id;
            join(rt,id);    // 连接该id与根节点。
        }
        if(m != 1)
            p.insert(finder(pre[rt]));// 保存根节点
    }
    cin&gt;&gt;k;
    for(int i = 0;i&lt;k;i++){
        cin&gt;&gt;id;
        if(!visit[id]){
            visit[id] = 1;
            int res = finder(pre[id]);
            auto sig = p.find(res);
            if(sig == p.end()) {    // 没有在某个朋友圈里
                if(!flag) cout&lt;&lt;&#39; &#39;;
                cout&lt;&lt;setw(5)&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;id;
                flag = 0;
            }
        }
    }
    if(flag) cout&lt;&lt;&quot;No one is handsome&quot;&lt;&lt;&#39;\n&#39;;
    else cout&lt;&lt;&#39;\n&#39;;
    return 0;
}
</code></pre>
<p>对于并查集，</p>
<ul>
<li>需要对根节点操作时，可以在录入数据时，指定某个点为为根节点，并将该节点加入set(红黑树)中，以备查找。</li>
<li>当题目存在大量节点查询时，此时路径压缩算法能起到很大的作用，而题目并没有大量查询时，路径压缩算法作用则不明显，反而会有额外时间开销。</li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>C++建立大整数类头文件及源文件</title>
    <url>/BigIntegerSamulation.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>　　前段时间用Java的BigInteger类做了一道题，于是便萌生了自己用C++实现一个BigInteger类的想法，顺带了解并掌握其底层算法。<br>　　准备阶段，我查阅了一下Java的BigInteger类的源代码(毕竟是轮子)，嗯，只是看了一下 ，然后开工。<br><a id="more"></a><br>　　首先我们分析一下BigInteger类<strong>成员变量</strong>以及<strong>成员函数</strong> :  </p>
<hr>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><ul>
<li>大整数数串（bigInteger）</li>
<li>大整数位数（length）</li>
<li>大整数的正负（signum）</li>
</ul>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><ul>
<li>加法+</li>
<li>减法-</li>
<li>乘法*</li>
<li>除法/</li>
<li>取余%</li>
</ul>
<hr>
<p>下面，我们一步一步的实现…</p>
<h2 id="第一步：建立头文件-BigInteger-h-声明-BigInteger类"><a href="#第一步：建立头文件-BigInteger-h-声明-BigInteger类" class="headerlink" title="第一步：建立头文件 BigInteger.h 声明 BigInteger类"></a>第一步：建立头文件 <em>BigInteger.h</em> 声明 BigInteger类</h2><p>　　这里我们用vector来存储大数，可以灵活的配置空间。</p>
<pre><code>#ifndef BIGINTEGER_H_INCLUDED
#define BIGINTEGER_H_INCLUDED
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
class BigInteger {
private:
    std::vector&lt;int&gt; bigInteger;        /* 保存大整数字串    */
    size_t length;                      /* 表示大整数长度    */
    int signum;                         /* 表示大整数正负 -1为负数 0表示数字0 1表示正数 */
public:
    // 构造函数
    BigInteger();                       /* 空无参构造函数    */
    BigInteger(const BigInteger &amp;);     /* 拷贝构造函数      */
    BigInteger(const std::string &amp;);    /* 字符串构造大整数  */
    // 成员函数
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, BigInteger &amp;);
    friend std::istream&amp; operator&gt;&gt;(std::istream&amp;, BigInteger &amp;);
    void setLength(const int&amp;);
    void setSignum(const int&amp;);
    int getLength();
    int getSignum();
    bool operator==(const BigInteger &amp;);
    bool operator&gt;(const BigInteger &amp;);
    void operator=(const BigInteger &amp;);
    BigInteger operator+(const BigInteger &amp;);
    BigInteger operator-(const BigInteger &amp;);
    BigInteger operator*(const BigInteger &amp;);
    BigInteger operator/(const BigInteger &amp;);
    BigInteger operator%(const BigInteger &amp;);
};
#endif // BIGINTEGER_H_INCLUDED
</code></pre><h2 id="第二步：实现功能（这里只详解主要功能，其它略）"><a href="#第二步：实现功能（这里只详解主要功能，其它略）" class="headerlink" title="第二步：实现功能（这里只详解主要功能，其它略）"></a>第二步：实现功能（这里只详解主要功能，其它略）</h2><p>　　我们先来看两个常数：</p>
<pre><code>const int LIMIT = 4;
const int CARRY = 1e4;
</code></pre><p><strong>LIMIT</strong>是<strong>bigInteger (vector<int>)</strong>每个元素存的整数的位数，因为vector<int>每个元素都存一个范围为<br> -2^31 至2^31 - 1的整数，最大的数位数为9位，考虑到最大的4位数相乘,也只有8位，故不会溢出int，所以选择存储4位数。<br> 而CARRY则是vector的每个元素的基数，到10000就进位。</p>
<h3 id="1-加法"><a href="#1-加法" class="headerlink" title="1.加法"></a>1.加法</h3><p>　　加法应该是最好实现的，只用从低位开始加，加完判断进位即可。<br>PS: <strong>代码块可左右滑动</strong></p>
<pre><code>BigInteger BigInteger::operator+(const BigInteger &amp;tmp)
{
    BigInteger t = *this, q = tmp;
    size_t len1, len2;
    if(t &gt; q)  swap(t, q);                          /* 前面重载了 &gt; 、= 和 == 运算符，选择位数多的加*/
    len1 = t.bigInteger.size();                     /* 位数少的，再更新它的属性。将其作为返回值。*/
    len2 = q.bigInteger.size();
    bool flag = false;
    for(size_t i = 0; i &lt; len2; i++) {              /* 索引小的为低位，大的为高位        */
        if(i &lt; len1)                                /* 防止越界            */
            q.bigInteger[i] += t.bigInteger[i];
        if(q.bigInteger[i] &gt;= CARRY) {
            if(i == len2 - 1) {                      /* 最高位进位为q扩容并加入1 */
                q.bigInteger.push_back(1);           /* 进1                 */
                q.bigInteger[i] -= CARRY;
                flag = true;
            } else {                                /* 高位进位          */
                q.bigInteger[i + 1]++;
                q.bigInteger[i] -= CARRY;           /* 保存本位           */
            }
        }
    }
    if(flag) q.length++;                            /* 最高位有进位       */
    return q;
}
</code></pre><h3 id="2-减法"><a href="#2-减法" class="headerlink" title="2.减法"></a>2.减法</h3><p>　　虽然减法不能交换两个数的位置，但是交换后对结果处理一下符号也可以。所以如果被减数大于减数，则直接进行减法；<br>如果被减数小于减数，则交换它们的位置，再相减，并为结果添上负号。减的时候如果结果小于零，此时需要向高位借位。</p>
<pre><code>BigInteger BigInteger::operator-(const BigInteger &amp;tmp)
{
    BigInteger q = *this, t = tmp;
    size_t len1, len2;
    if(q == t) {                                    /*两数相等则直接返回0*/
        BigInteger r(&quot;0&quot;);
        return r;
    }
    if(q &gt; t) {
        len1 = q.bigInteger.size();
        len2 = t.bigInteger.size();
        for(size_t i = 0; i &lt; len1; i++) {
            if(i &lt; len2)                            /*防止越界          */
                q.bigInteger[i] -= t.bigInteger[i];
            if(q.bigInteger[i] &lt; 0) {               /* 本位所减的结果小于0则向高位借位 */
                q.bigInteger[i + 1]--;
                q.bigInteger[i] += CARRY;           /*  更新本位        */
            }
        }
        // 高位去0
        for(int i = len1 - 1; i &gt;= 0; i--) {        /* 因为q的最高位 只能大于等于t的最高位，         */
            if(q.bigInteger[i] == 0) {              /* 当它们最高位相等时,此时最高位为0，用此算法    */
                q.length -= LIMIT;                  /* 把高位的0去掉                                 */
                q.bigInteger.pop_back();
            } else break;                           /* 从最高位开始扫描，遇到第一个不为0的数则跳出   */
        }
        // 更新大数的长度
        q.length = (q.bigInteger.size() - 1) * LIMIT;   /* 重新计算最高位的位数                   */
        int k = q.bigInteger.back();
        while(k) {                                  /*  计算位数        */
            k /= 10;
            q.length++;
        }
        return q;
    } else {
        len1 = t.bigInteger.size();
        len2 = q.bigInteger.size();
        for(size_t i = 0; i &lt; len1; i++) {
            if(i &lt; len2)
                t.bigInteger[i] -= q.bigInteger[i];
            if(t.bigInteger[i] &lt; 0) {
                t.bigInteger[i + 1]--;
                t.bigInteger[i] += CARRY;
            }
        }
        // 大数符号
        t.signum = -1;                              /*  反过来减，结果为负数*/
        // 高位去0
        for(int i = len1 - 1; i &gt;= 0; i--) {
            if(t.bigInteger[i] == 0) {
                t.length -= LIMIT;
                t.bigInteger.pop_back();
            } else break;
        }
        t.length = (t.bigInteger.size() - 1) * LIMIT;
        int k = t.bigInteger.back();
        while(k) {
            k /= 10;
            t.length++;
        }
        return t;
    }
}
</code></pre><p>   <strong>加减只支持无符号大整数运算,因为在算的时候可以灵活的加括号与换符号</strong></p>
<h3 id="3-乘法"><a href="#3-乘法" class="headerlink" title="3.乘法"></a>3.乘法</h3><p>　　乘法依照竖式算法，被乘数的每一位和乘数的每一位相乘并将结果保存到相应的位置，且该相应位置应加上上一位的进位与本位值。</p>
<pre><code>BigInteger BigInteger::operator*(const BigInteger &amp;tmp)
{
    BigInteger t = *this, q = tmp, r;
    int carry;
    size_t i, j;
    size_t len1 = t.bigInteger.size(), len2 = q.bigInteger.size();
    vector&lt;int&gt; T(len1+len2, 0);
    for(i = 0; i &lt; len1; i++) {
        carry = 0;
        for(j = 0; j &lt; len2; j++) {
            int temp = t.bigInteger[i] * q.bigInteger[j] + T[i + j] + carry;  /* 保存第i位与第j位的乘积，并加上本位与进位值*/
            if(temp &gt;= CARRY) {
                carry = temp / CARRY;                                         /* 保存进位值 */
                T[i + j] = temp - temp / CARRY * CARRY;                       /* 更新本位值 */
            } else {
                carry = 0;
                T[i + j] = temp;
            }
        }
        if(carry != 0) 
        T[i + j] = carry;                                      /* 最高位进位 */
    }
    // 处理符号
    if(t.signum &lt; 0 &amp;&amp; q.signum &lt; 0)
        r.signum = 1;
    else {
        if(t.signum &lt; 0 || q.signum &lt; 0)
            q.signum = -1;
        else if(t.signum == 0 || q.signum == 0) {
            r.signum = 0;
        } else {
            r.signum = 1;
        }
    }
    // 处理长度
    if(r.signum != 0) {                                                      /* 先判断结果的符号 */
        //  高位去0
        for(int i = T.size() - 1; i &gt;= 0; i--) {
            if(T[i] == 0) {
                T.pop_back();
            } else {
                break;
            }
        }
        // 数字串长度
        r.length = (T.size() - 1) * LIMIT;
        int k = T.back();
        while(k) {
            k /= 10;
            r.length++;
        }
        r.bigInteger = T;
    } else {
        r.length = 1;
        T.resize(1);
        r.bigInteger = T;
    }
    return r;
}
</code></pre><h3 id="4-除法"><a href="#4-除法" class="headerlink" title="4.除法"></a>4.除法</h3><p>　　判定大小，如果被除数等于除数，返回1；如果被除数小于除数，返回0；如果被除数大于除数，则进入除法，最简单的就是反复的做减法，看能减多少个除数。这里只介绍最基础的<br>法。还有一种将这种方法优化一些的算法，完整版见我的Github <a href="https://github.com/lightingmoon/">明月光</a>。</p>
<pre><code>BigInteger BigInteger::operator/(const BigInteger &amp;tmp)     // 最基础的算法，效率上可能有不足
{
    BigInteger q = *this , t = tmp, ans, ZERO(&quot;0&quot;);
    assert(!(t == ZERO));                       /* 除数不为0                */
    if(q == ZERO) return ZERO;                  /* 被除数为0返回0           */
    if(q == t) {                                /* 两数相等则直接返回1      */
        ans.signum = 1;
        ans.length = 1;
        ans.bigInteger.push_back(1);
    } else {
        if(q &gt; t) {                             /* 被除数大于除数，开始整除 */
            vector&lt;int&gt; T(100, 0);
            int index = 0, maxl = 0;
            while(true) {
                q = q - t;
                if(ZERO &gt; q) {
                    if(!(ZERO == q)) break;     /* 直到减到q小于零，当能整除的时候要将商加1 */
                }
                T[index]++;
                if(T[index] &gt;= CARRY) {         /*判定进位              */
                    T[index] = 0;
                    T[++index]++;
                    maxl = max(maxl, index);
                    for(int i = index; i &lt; maxl; i++) {
                        if(T[i] &gt;= CARRY) {
                            T[i + 1]++;
                            T[i] = 0;
                        }
                    }
                    index = 0;                  /* 重回最低位累加      */
                }
            }
            T.resize(maxl + 1);                 /* 缩放空间             */
            if(q.signum &lt; 0 &amp;&amp; t.signum &lt; 0)
                q.signum = 1;
            else {
                if(q.signum &lt; 0 || t.signum &lt; 0) 
                    q.signum = -1;
                else {
                    q.signum = 1;
                }
            }
            ans.bigInteger = T;
        } else {
            ans = ZERO;
        }
    }
    return ans;
}
</code></pre><h3 id="5-取余"><a href="#5-取余" class="headerlink" title="5.取余"></a>5.取余</h3><p>　　最简单的方法，代码如下2333333…</p>
<pre><code>BigInteger BigInteger::operator%(const BigInteger &amp;tmp)
{
    BigInteger q = *this, t = tmp, ZERO(&quot;0&quot;), m;
    assert(!(q==ZERO));
    assert(!(t==ZERO));
    m = q / t;
    return q - (m * t);
}
</code></pre><p>　　这里还有另一种模拟取余的方法，</p>
<pre><code>long long BigInteger::operator%(const long long &amp;tmp)
{
    BigInteger q = *this;
    long long mod = 0, len = q.bigInteger.size();
    for(int i = len - 1; i &gt;= 0; i--) {
        mod = ((mod * CARRY)%tmp + q.bigInteger[i]) % tmp;
    }
    return mod;
}
</code></pre><p>下面是一些测试:</p>
<pre><code>开始测试
p:1234567890123456789
q:123456789012345678
p - q = 1111111101111111111
p + q = 1358024679135802467
p * q = 152415787532388366390794098763907942
p / q = 10
p % q = 9
p % 1234567890 = 123456789
结束测试
</code></pre><p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/u010983881/article/details/77503519">【算法】大数乘法问题及其高效算法</a></li>
<li><a href="https://blog.csdn.net/hackbuteer1/article/details/6595881">C++大数模板</a></li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>大整数类</tag>
      </tags>
  </entry>
  <entry>
    <title>千寻诗意，洒脱如风</title>
    <url>/mysoul.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><blockquote>
<p>白云一片去悠悠，青枫浦上不胜愁。谁家今夜扁舟子，何处相思明月楼。——张若虚      </p>
</blockquote>
<a id="more"></a>
<center><h4>自定义</h4></center>
我如浮云般漂浮不定，又如江中磐石，永不动摇。所寄者，洒脱也。古人狂歌痛饮三大白作离别，诗仙斗酒诗百篇以明志，我辈又如何能望其项背？    
然太史公曰：“高山仰止，景行行止，虽不能至，然心向往之”，必穷尽一生去追求也。    
金岳霖为林徽因终生未娶，满怀期待与林的下一辈子的爱情。在林去世时，金为她写下这样的诗句：“一身诗意千寻瀑，万古人间四月天”。林惊才艳艳，金又何尝不是呢？若不是他们的千寻诗意，便没有今天这洒脱如风的诗句了吧。 或者说若没有他们的洒脱如风，便没有这般光芒万丈的珍奇了吧。只是赞叹，只有赞叹。
就像深入灵魂，像蜡炬成灰泪始干，像女儿红...
<center><h4>重定义</h4>
<img src="image/KnowYourself.jpg"  height="75" width="125" />
</img></center>
<center><font size="2">一 . 认识自己</font></center>

<p>古希腊阿波罗神殿门楣的石板上刻着这样一行字: 认识你自己。这寥寥几个字从人类文明发祥伊始，至现代，一直是一个长久不衰的话题。而我们又如何去认识自己呢？<br>问题的答案如同一千个人眼中的《哈姆雷特》，各有千秋。坚守自己的“哈姆雷特”让独特欲盖弥彰。</p>
<center><font size="2">二 . 改变自己</font> </center>

<p>在威斯敏斯特大教堂地下室的墓碑林中，有一块闻名于世的墓碑。<br>它普通而又不平凡。普通是因为它周围都是诸如狄更斯、达尔文等世界名人的装饰华丽的墓碑，而它却只是粗糙的花岗岩质地，造型也一般，甚至连墓志铭都没有——是一块无名氏墓碑；<br>不平凡是因为每一位到过这里的人，他们可以不去拜谒世界名人，但是定会来到这座墓碑前，进而被它深深地震撼。因为这座墓碑上刻着这样一段碑文：    </p>
<blockquote>
<p>When I was young and free and my imagination had no limits, I dreamed of changing the world. As I grew older and wiser, I discovered the world would not change, so I shortened my sights somewhat and decided to change my country. But it, too, seemed immovable. As I grew into my twilight years, in one last desperate attempt, I settled for changing only my family, those closest to me. But alas, they would have none of it. And now, as I lie on my bed, I suddenly realize:If I had only changed  myself first, then by example I would have changed my family. From their inspiration and encouragement, I would then have been able to better my country, and who knows I may have even change the world.    </p>
</blockquote>
<p><center><h4>终定义</h4></center><br>漫漫长路，如何在有限的生命中寻到人生终极价值？青山不语，冷月云蔽，唯见旧时的风载着新落的叶缓缓而沉。</p>
]]></content>
      <categories>
        <category>静夜思</category>
      </categories>
      <tags>
        <tag>静夜思</tag>
      </tags>
  </entry>
  <entry>
    <title>斜月三观</title>
    <url>/views/index.html</url>
    <content><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<p><center><img src="../image/Himag.jpg"  height="50" width="50" alt="小鲸鱼" /></center><br>大千世界，很庆幸我们的相遇。<br>关于我的思想、价值观（不同时期）都在下面的诗文中。均是我用心写就。<br>您可以细细品味，与你的思想相互印证。<br>如果您能在这里略有所获，这是我的荣幸。<br>如果您的思想与我的思想产生了共鸣，那么请联系我。<br>古人云：<br>　　杨意不逢，抚凌云而自惜；<br>　　钟期既遇，奏流水以何惭？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">QQ</td>
<td style="text-align:center">1451145190</td>
</tr>
<tr>
<td style="text-align:center">Github</td>
<td style="text-align:center"><a href="https://github.com/lightingmoon/">明月光</a></td>
</tr>
<tr>
<td style="text-align:center">邮箱</td>
<td style="text-align:center">lightingdream@qq.com</td>
</tr>
</tbody>
</table>
</div>
<hr>
<center>

<blockquote>
<p>寰宇苍茫，逝川如殇，<br>杳杳无尽，恒远流长。<br>天戴其阳，地履其霜，<br>朔气消尽，煦风回堂。<br>流火微凉，萧瑟难芳，<br>千红摇落，彼花非黄。<br>逆旅长廊，客行异乡，<br>花火繁树，歌舞升藏。<br>草木一秋，皆为虚妄，<br>红尘莽莽，转瞬如常，<br>心若不怅，地老天荒。<br>山之高仰，水有沧浪，<br>大道景行，清浊自量。<br>雪月清妆，幽兰自赏，<br>怒不争也，奈何无望，<br>哀不幸也，回天无方。<br>天外仙恍，落拓而扬。<br>by 雪林 20180214</p>
</blockquote>
<hr>
<blockquote>
<p> 《悲欢离合》  </p>
<p>“我此来长安，新学了一个词，<br>但一直不解其意，<br>不知在座哪位贤才能解答一二。<br>这个词是悲、欢、离、合。”<br>“这有何难？”  </p>
<p>悲是黯然伤神情不自胜<br>欢是无人问询空谷足声<br>离是柳叶传情盏茶未冷<br>合是余温尚存歌舞升腾  </p>
<p>一点灵光，千夜所向<br>得失几何，莫忘默忘<br>天所愿者，晴空一方<br>地所栖者，绿荫一凉<br>寒来暑往，秋收冬藏  </p>
<p>悲是耳目失聪初识缺省<br>欢是心容星空两笑无争<br>离是曲终人散再会不曾<br>合是把酒言欢此情最盛  </p>
<p>高天之上，极目无光<br>沙砾天堂，生灭股掌<br>最初而亡，永劫继尚<br>识之无涯，莫忘默忘<br>作何以观，如是狂想  </p>
<p>悲是咫尺天涯同枕异梦<br>欢是心有灵犀彩翼乘风<br>离是大千失色弦月失衡<br>合是云空见虹月正相逢  </p>
<p>悲是失路忘返心迷智蒙<br>欢是临渊绝步赏游樱城<br>离是三秋如昨忽然过缝<br>合是闲敲棋子仲秋三更  </p>
<p>by 雪林 20190324</p>
<hr>
<p>光阴流转，</p>
<p>儿时的回忆如同退潮的海滩上的小水洼，</p>
<p>那一个个鲜明的人和事就像水洼中的小鱼，</p>
<p>努力想拾起一条条小鱼将之扔回记忆之海，有人问谁在乎？</p>
<p>我会说，这条在乎，那条也在乎，还有那条。</p>
<hr>
<p>by 雪林 20200329</p>
</blockquote>
<hr>
<p><i>此页面不定时更新…</i></p>
]]></content>
  </entry>
</search>
