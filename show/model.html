<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <title>Demo</title>
  <link rel="shortcut icon" href="https://www.bos.xyz/favicon.ico" />
  <link rel="stylesheet" href="https://xhz3d.bos.xyz/v1/Xhz.min.css">
  <script src="https://xhz3d.bos.xyz/v1/Xhz.min.js"></script>
 </head>
 <body>
  <div id="viewport"></div>   
 </body>
 <script>
  Xhz.init(function () {
   const options = {
    modelKey: "509396040", // 文件key
    devcode: "ac429135053c84cc718159001ec59ecf", // 开发密钥
    toolbar: {
     list: [
      "home", // 初始化
      "reset", // 复位
      "roam", // 路径漫游
      "focus", // 构件聚焦
      "select", // 构件框选
      "hide", // 构件隐藏
      "isolate", // 构件隔离
      "color", // 构件变色
      "sectioning", // 模型剖切
      "decompose", // 模型分解
      "wire", // 构件线框化
      "tree", // 模型树 
      "attribute", // 构件属性
      "measure", // 模型测量
      "mark", // 添加标签
      "snapshoot", // 快照
      "backgroundcolor", // 背景颜色
      "fullscreen", // 全屏
     ]
    }
   };
	const app = new Xhz.App(options);
    const { model, view, camera } = app;

    const scene = view.getScene();
	model.on("load", function (event) {
        addText("1 4 5 1 1 4 5 1 9 0", "509396040_3DtBi08dD8088X4TTzPs7H");
    });
	
   const addText = (content, componentId) => {
	// 获取当前构件的包围盒中心
	const centerObj = new THREE.Vector3();
	const viewer = view.getViewer3d();
	const position = viewer
		.getViewerImpl()
		.modelManager.getComponent(componentId)[0]
		.boundingBox.getCenter(centerObj);

		addThreeDimensionalText(
			{
				content,
				color: 0xff0000,
				position: [position.x + 100, position.y + 30, position.z + 50],
				scale: 0.1,
				textpath: "fonts/helvetiker_regular.typeface.json", // 三维字体路径
			},
			(text) => {
				scene.add(text); // 创建字体后，将三维字体添加进三维场景
			}
		);
	};
	
	/**
     * 该方法用来通过给出内容加载出来3d字体，暂不支持中文
     * @params:  componentid {string}
     * @params:  callback {function} 回调函数
     * @param [options] {object} 参数
     * @param [options.color]{16进制颜色}  字体的颜色 例如0xff0000
     * @param [options.content]{String}  三维字体的内容
     * @param [options.textpath]{String}  三维字体的路径
     * @param [options.position]{Array}  三维字体的相对于构件位置的偏移X
     * @param [options.depthTest]{boolen}  是否关闭字体的深度测试
     * @param [options.textLength]{number}  三维字体的长度
     * @param [options.textWidth]{boolen}  三维字体的宽度
     * @param [options.componentId]{String}  三维构件的id，如果传入，默认位置为构件位置
     * @params:
     * @return:
     */
    const addThreeDimensionalText = function (options, callback) {
        var xMid, text, message;
        var loader = new THREE.FontLoader();
        var defaultSetting = {
            color: 0xff0000,
            content: "https://xhz.bos.xyz/",
            textpath:
                "https://www.bos.xyz/vizbim/fonts/helvetiker_regular.typeface.json",
            position: [0, 0, 0],
            depthTest: false,
            textLength: 1000,
            textWidth: 1000,
            scale: 1,
            defaultPosition: [0, 0, 0],
            key: "",
        };
        var option = {};
        option = Object.assign(defaultSetting, options);
        loader.load(option.textpath, function (font) {
            var textShape = new THREE.BufferGeometry();

            var color = option.color;

            var matDark = new THREE.LineBasicMaterial({
                color: color,
                side: THREE.DoubleSide,
            });

            var matLite = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide,
            });

            message = option.content;

            var shapes = font.generateShapes(
                message,
                option.textLength * option.scale,
                option.textWidth * option.scale
            );

            var geometry = new THREE.ShapeGeometry(shapes);

            geometry.computeBoundingBox();

            xMid =
                -0.5 *
                (geometry.boundingBox.max.x - geometry.boundingBox.min.x);

            geometry.translate(xMid, 0, 0);

            // make shape ( N.B. edge view not visible )

            textShape.fromGeometry(geometry);

            text = new THREE.Mesh(textShape, matLite);
            text.key = option.key;

            text.position.x = option.position[0];
            text.position.y = option.position[1];
            text.position.z = option.position[2];
            // text.rotation.x+=Math.PI/2;
            // text.rotation.y+=Math.PI/2;
			text.material.depthTest = option.depthTest;
			const viewer = view.getViewer3d();
			
            viewer
                .getViewerImpl()
                .cameraControl.addEventListener(
                    "ON_CAMERA_CHANGE",
                    function () {
                        updateTextView();
                    }
                );
            viewer
                .getViewerImpl()
                .modelManager.addEventListener("ON_LOAD_COMPLETE", function () {
					updateTextView();
                });
            // 更新三维字体视角，始终面向相机
            function updateTextView() {
				const cameraObj = viewer.getViewerImpl().camera;
                text.rotation.x = cameraObj.rotation.x;
                text.rotation.y = cameraObj.rotation.y;
                text.rotation.z = cameraObj.rotation.z;
                view.render();
            }
            callback(text);
        });
	};
	
  });
 </script>
</html>